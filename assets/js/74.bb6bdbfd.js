(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{501:function(a,e,t){"use strict";t.r(e);var s=t(25),n=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"创建dockfile流程"}},[a._v("创建dockfile流程")]),a._v(" "),t("ol",[t("li",[a._v("创建一个项目目录")]),a._v(" "),t("li",[a._v("创建一个Dockerfile文件")])]),a._v(" "),t("h2",{attrs:{id:"from-和-run-指令的作用"}},[a._v("FROM 和 RUN 指令的作用")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。")])]),a._v(" "),t("li",[t("p",[a._v("RUN：用于执行后面跟着的命令行命令。有以下俩种格式：\nshell 格式：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("  exec 格式：\n")])])])])]),a._v(" "),t("h2",{attrs:{id:"开始构建镜像"}},[a._v("开始构建镜像")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("    docker build -t nginx:test .\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("上下文路径\n"),t("img",{attrs:{src:"https://images-1255533533.cos.ap-shanghai.myqcloud.com/20200801014345_eaf009c6d1b4c673bd0166a9a80e1bbb.png",alt:"20200801014345_eaf009c6d1b4c673bd0166a9a80e1bbb.png"}})]),a._v(" "),t("h2",{attrs:{id:"指令详解"}},[a._v("指令详解")]),a._v(" "),t("h3",{attrs:{id:"copy"}},[a._v("COPY")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>\n")])])]),t("p",[a._v("COPY [--chown="),t("user",[a._v(":"),t("group",[a._v('] ["<源路径1>",...  "<目标路径>"]')])],1)],1),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("<目标路径>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。\n")])])]),t("h3",{attrs:{id:"add"}},[a._v("ADD")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下\nADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。\nADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。\n")])])]),t("h3",{attrs:{id:"cmd"}},[a._v("CMD")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\nCMD 在docker run 时运行。\nRUN 是在 docker build。\n作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\n格式：\n\tCMD <shell 命令> \n\tCMD ["<可执行文件或命令>","<param1>","<param2>",...] \n\tCMD ["<param1>","<param2>",...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数\n\t推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。\n')])])]),t("h3",{attrs:{id:"entrypoint"}},[a._v("ENTRYPOINT")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。\n注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\n格式：\n\tENTRYPOINT ["<executeable>","<param1>","<param2>",...]\n可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。\n\n1、不传参运行\n\t\n2、传参运行\n\t\n类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。\n')])])]),t("h3",{attrs:{id:"env"}},[a._v("ENV")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。\n格式：\n\tENV <key> <value>\n\tENV <key1>=<value1> <key2>=<value2>...\n")])])]),t("h3",{attrs:{id:"arg"}},[a._v("ARG")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。\n")])])]),t("p",[a._v("构建命令 docker build 中可以用 --build-arg <参数名>=<值> 来覆盖。\n格式：\nARG <参数名>[=<默认值>]")]),a._v(" "),t("h3",{attrs:{id:"volume"}},[a._v("VOLUME")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n作用：\n\t避免重要的数据，因容器重启而丢失，这是非常致命的。\n\t避免容器不断变大。\n格式：\n\tVOLUME ["<路径1>", "<路径2>"...]\n\tVOLUME <路径>\n在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\n')])])]),t("h3",{attrs:{id:"expose"}},[a._v("EXPOSE")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("仅仅只是声明端口。\n作用：\n\t帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n\t在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\nEXPOSE <端口1> [<端口2>...]\n")])])]),t("h3",{attrs:{id:"workdir"}},[a._v("WORKDIR")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。\n")])])]),t("h3",{attrs:{id:"docker-build-构建镜像过程中的，每一个-run-命令都是新建的一层。只有通过-workdir-创建的目录才会一直存在。"}},[a._v("docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("格式：\n\tWORKDIR <工作目录路径>\n")])])]),t("h3",{attrs:{id:"user"}},[a._v("USER")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。\n格式：\n\tUSER <用户名>[:<用户组>]\n")])])]),t("h3",{attrs:{id:"healthcheck"}},[a._v("HEALTHCHECK")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\n格式：\n\tHEALTHCHECK [选项] CMD <命令>：设置检查容器健康状况的命令\n\tHEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\n\tHEALTHCHECK [选项] CMD <命令> : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。\n")])])]),t("h3",{attrs:{id:"onbuild"}},[a._v("ONBUILD")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。\n格式：\n\tONBUILD <其它指令>")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);