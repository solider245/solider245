<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Dockerfile官方参考 | 吴起的个人网站</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="https://images-1255533533.cos.ap-shanghai.myqcloud.com/20190817214528_05c52e04cf64654248918bfc2a1f64ab.png">
    <link rel="manifest" href="/VuePress-blog/manifest.json">
    <link rel="apple-touch-icon" href="/VuePress-blog/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/VuePress-blog/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="官方的参考资料">
    <meta name="author" content="中箭的吴起">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/VuePress-blog/assets/css/0.styles.f7cbc213.css" as="style"><link rel="preload" href="/VuePress-blog/assets/js/app.e4354aa1.js" as="script"><link rel="preload" href="/VuePress-blog/assets/js/2.398f4283.js" as="script"><link rel="preload" href="/VuePress-blog/assets/js/145.8f4496ac.js" as="script"><link rel="prefetch" href="/VuePress-blog/assets/js/10.f88a1831.js"><link rel="prefetch" href="/VuePress-blog/assets/js/100.618f4056.js"><link rel="prefetch" href="/VuePress-blog/assets/js/101.b170cbee.js"><link rel="prefetch" href="/VuePress-blog/assets/js/102.8cd82e5b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/103.a9e55775.js"><link rel="prefetch" href="/VuePress-blog/assets/js/104.2b910c17.js"><link rel="prefetch" href="/VuePress-blog/assets/js/105.badde638.js"><link rel="prefetch" href="/VuePress-blog/assets/js/106.cabb5a4b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/107.55916750.js"><link rel="prefetch" href="/VuePress-blog/assets/js/108.a894756d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/109.665bfa12.js"><link rel="prefetch" href="/VuePress-blog/assets/js/11.82bfc211.js"><link rel="prefetch" href="/VuePress-blog/assets/js/110.82d9d03d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/111.a3bf7bb5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/112.308d5801.js"><link rel="prefetch" href="/VuePress-blog/assets/js/113.aaf33f56.js"><link rel="prefetch" href="/VuePress-blog/assets/js/114.896dc3c8.js"><link rel="prefetch" href="/VuePress-blog/assets/js/115.33bf424e.js"><link rel="prefetch" href="/VuePress-blog/assets/js/116.6a8b1073.js"><link rel="prefetch" href="/VuePress-blog/assets/js/117.00678fec.js"><link rel="prefetch" href="/VuePress-blog/assets/js/118.6bc9e989.js"><link rel="prefetch" href="/VuePress-blog/assets/js/119.31a2372f.js"><link rel="prefetch" href="/VuePress-blog/assets/js/12.f528b4f1.js"><link rel="prefetch" href="/VuePress-blog/assets/js/120.d1bd65a5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/121.6ff9895f.js"><link rel="prefetch" href="/VuePress-blog/assets/js/122.f80812c8.js"><link rel="prefetch" href="/VuePress-blog/assets/js/123.457af999.js"><link rel="prefetch" href="/VuePress-blog/assets/js/124.a62fbdae.js"><link rel="prefetch" href="/VuePress-blog/assets/js/125.8d1225d4.js"><link rel="prefetch" href="/VuePress-blog/assets/js/126.9e329698.js"><link rel="prefetch" href="/VuePress-blog/assets/js/127.e3eac40d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/128.73562074.js"><link rel="prefetch" href="/VuePress-blog/assets/js/129.7dc75ed6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/13.0c9fc526.js"><link rel="prefetch" href="/VuePress-blog/assets/js/130.282ea90d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/131.948f43a2.js"><link rel="prefetch" href="/VuePress-blog/assets/js/132.aa7a4d25.js"><link rel="prefetch" href="/VuePress-blog/assets/js/133.0608bab7.js"><link rel="prefetch" href="/VuePress-blog/assets/js/134.4a1bb517.js"><link rel="prefetch" href="/VuePress-blog/assets/js/135.2449e034.js"><link rel="prefetch" href="/VuePress-blog/assets/js/136.018a7818.js"><link rel="prefetch" href="/VuePress-blog/assets/js/137.c586e53d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/138.5b043595.js"><link rel="prefetch" href="/VuePress-blog/assets/js/139.f535affe.js"><link rel="prefetch" href="/VuePress-blog/assets/js/14.d9747bc8.js"><link rel="prefetch" href="/VuePress-blog/assets/js/140.b1f108ce.js"><link rel="prefetch" href="/VuePress-blog/assets/js/141.ce586450.js"><link rel="prefetch" href="/VuePress-blog/assets/js/142.7f88da6d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/143.d3ce1076.js"><link rel="prefetch" href="/VuePress-blog/assets/js/144.b924a878.js"><link rel="prefetch" href="/VuePress-blog/assets/js/146.f77f5ae7.js"><link rel="prefetch" href="/VuePress-blog/assets/js/147.8892e259.js"><link rel="prefetch" href="/VuePress-blog/assets/js/148.ac76523d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/149.036ba33d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/15.0ec2a8ee.js"><link rel="prefetch" href="/VuePress-blog/assets/js/150.ec99cda4.js"><link rel="prefetch" href="/VuePress-blog/assets/js/151.6b1887cc.js"><link rel="prefetch" href="/VuePress-blog/assets/js/152.3c509f41.js"><link rel="prefetch" href="/VuePress-blog/assets/js/153.470b653b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/154.d79fdff7.js"><link rel="prefetch" href="/VuePress-blog/assets/js/155.42fb4d54.js"><link rel="prefetch" href="/VuePress-blog/assets/js/156.ce6ca9d0.js"><link rel="prefetch" href="/VuePress-blog/assets/js/157.5da875cb.js"><link rel="prefetch" href="/VuePress-blog/assets/js/158.95349a8a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/159.c6d5d3f6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/16.96972e23.js"><link rel="prefetch" href="/VuePress-blog/assets/js/160.fd6be3d0.js"><link rel="prefetch" href="/VuePress-blog/assets/js/161.645951a6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/162.f91af681.js"><link rel="prefetch" href="/VuePress-blog/assets/js/163.4ff37798.js"><link rel="prefetch" href="/VuePress-blog/assets/js/164.0ab0411b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/165.fb3e31ca.js"><link rel="prefetch" href="/VuePress-blog/assets/js/166.0e89f139.js"><link rel="prefetch" href="/VuePress-blog/assets/js/167.6910f6cf.js"><link rel="prefetch" href="/VuePress-blog/assets/js/168.dba298af.js"><link rel="prefetch" href="/VuePress-blog/assets/js/169.c8da94cc.js"><link rel="prefetch" href="/VuePress-blog/assets/js/17.06889e54.js"><link rel="prefetch" href="/VuePress-blog/assets/js/170.dfc7fbab.js"><link rel="prefetch" href="/VuePress-blog/assets/js/171.75cc843a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/172.3a98f4d2.js"><link rel="prefetch" href="/VuePress-blog/assets/js/173.25f0a60f.js"><link rel="prefetch" href="/VuePress-blog/assets/js/18.db5ae82d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/19.4055eeb9.js"><link rel="prefetch" href="/VuePress-blog/assets/js/20.0b68f787.js"><link rel="prefetch" href="/VuePress-blog/assets/js/21.64b18850.js"><link rel="prefetch" href="/VuePress-blog/assets/js/22.a548f3c5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/23.04a0e73a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/24.109f764e.js"><link rel="prefetch" href="/VuePress-blog/assets/js/25.7fa1c42f.js"><link rel="prefetch" href="/VuePress-blog/assets/js/26.cfaf31c5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/27.ebbc7ee9.js"><link rel="prefetch" href="/VuePress-blog/assets/js/28.51f27455.js"><link rel="prefetch" href="/VuePress-blog/assets/js/29.34168ce5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/3.9fb4597b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/30.96e95f78.js"><link rel="prefetch" href="/VuePress-blog/assets/js/31.63fbbffa.js"><link rel="prefetch" href="/VuePress-blog/assets/js/32.649cbad2.js"><link rel="prefetch" href="/VuePress-blog/assets/js/33.f7e81235.js"><link rel="prefetch" href="/VuePress-blog/assets/js/34.ca4331e1.js"><link rel="prefetch" href="/VuePress-blog/assets/js/35.0b860b77.js"><link rel="prefetch" href="/VuePress-blog/assets/js/36.d2f4ba78.js"><link rel="prefetch" href="/VuePress-blog/assets/js/37.c2877be5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/38.b345c513.js"><link rel="prefetch" href="/VuePress-blog/assets/js/39.0a91f037.js"><link rel="prefetch" href="/VuePress-blog/assets/js/4.7fa94338.js"><link rel="prefetch" href="/VuePress-blog/assets/js/40.3540778f.js"><link rel="prefetch" href="/VuePress-blog/assets/js/41.b4236deb.js"><link rel="prefetch" href="/VuePress-blog/assets/js/42.c525cdf5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/43.57682d62.js"><link rel="prefetch" href="/VuePress-blog/assets/js/44.bf75d21a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/45.9b8489e6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/46.e142d725.js"><link rel="prefetch" href="/VuePress-blog/assets/js/47.f5eec595.js"><link rel="prefetch" href="/VuePress-blog/assets/js/48.745b0e5d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/49.86bf2483.js"><link rel="prefetch" href="/VuePress-blog/assets/js/5.587b09c2.js"><link rel="prefetch" href="/VuePress-blog/assets/js/50.b05cd91e.js"><link rel="prefetch" href="/VuePress-blog/assets/js/51.1c8e588d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/52.fa48d599.js"><link rel="prefetch" href="/VuePress-blog/assets/js/53.2b6a2ab1.js"><link rel="prefetch" href="/VuePress-blog/assets/js/54.eb443023.js"><link rel="prefetch" href="/VuePress-blog/assets/js/55.bf5c3551.js"><link rel="prefetch" href="/VuePress-blog/assets/js/56.ce341c9a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/57.329c792a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/58.1321afa7.js"><link rel="prefetch" href="/VuePress-blog/assets/js/59.fe23f6db.js"><link rel="prefetch" href="/VuePress-blog/assets/js/6.6fd5799c.js"><link rel="prefetch" href="/VuePress-blog/assets/js/60.0320d1d5.js"><link rel="prefetch" href="/VuePress-blog/assets/js/61.c4846f1c.js"><link rel="prefetch" href="/VuePress-blog/assets/js/62.ff70299a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/63.41cc17ab.js"><link rel="prefetch" href="/VuePress-blog/assets/js/64.082d9540.js"><link rel="prefetch" href="/VuePress-blog/assets/js/65.1c25d870.js"><link rel="prefetch" href="/VuePress-blog/assets/js/66.7014dd6b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/67.71c256c6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/68.90d240a2.js"><link rel="prefetch" href="/VuePress-blog/assets/js/69.5047f2f6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/7.6ba377b6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/70.be70817b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/71.1c9efc31.js"><link rel="prefetch" href="/VuePress-blog/assets/js/72.b3eb16bb.js"><link rel="prefetch" href="/VuePress-blog/assets/js/73.b72b7959.js"><link rel="prefetch" href="/VuePress-blog/assets/js/74.bb6bdbfd.js"><link rel="prefetch" href="/VuePress-blog/assets/js/75.18b81eb3.js"><link rel="prefetch" href="/VuePress-blog/assets/js/76.fc2302e3.js"><link rel="prefetch" href="/VuePress-blog/assets/js/77.c0bd9e33.js"><link rel="prefetch" href="/VuePress-blog/assets/js/78.c339860d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/79.23c005e6.js"><link rel="prefetch" href="/VuePress-blog/assets/js/8.7a42445d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/80.838feb78.js"><link rel="prefetch" href="/VuePress-blog/assets/js/81.1b93e8a9.js"><link rel="prefetch" href="/VuePress-blog/assets/js/82.13eb4655.js"><link rel="prefetch" href="/VuePress-blog/assets/js/83.201aba60.js"><link rel="prefetch" href="/VuePress-blog/assets/js/84.ac1d8d4d.js"><link rel="prefetch" href="/VuePress-blog/assets/js/85.dd526c02.js"><link rel="prefetch" href="/VuePress-blog/assets/js/86.1ff01b81.js"><link rel="prefetch" href="/VuePress-blog/assets/js/87.668a3110.js"><link rel="prefetch" href="/VuePress-blog/assets/js/88.1a20f59b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/89.da33bb07.js"><link rel="prefetch" href="/VuePress-blog/assets/js/9.053b461b.js"><link rel="prefetch" href="/VuePress-blog/assets/js/90.4ec9f95f.js"><link rel="prefetch" href="/VuePress-blog/assets/js/91.818e056a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/92.3fe61856.js"><link rel="prefetch" href="/VuePress-blog/assets/js/93.458534e9.js"><link rel="prefetch" href="/VuePress-blog/assets/js/94.8849d84e.js"><link rel="prefetch" href="/VuePress-blog/assets/js/95.be1f911a.js"><link rel="prefetch" href="/VuePress-blog/assets/js/96.295835c7.js"><link rel="prefetch" href="/VuePress-blog/assets/js/97.6cb68243.js"><link rel="prefetch" href="/VuePress-blog/assets/js/98.056edaa4.js"><link rel="prefetch" href="/VuePress-blog/assets/js/99.34645cba.js">
    <link rel="stylesheet" href="/VuePress-blog/assets/css/0.styles.f7cbc213.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/VuePress-blog/" class="home-link router-link-active"><!----> <span class="site-name">吴起的个人网站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章转载" class="dropdown-title"><span class="title">文章转载</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/" class="nav-link">
  首页
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/Linux常见命令/" class="nav-link">
  Linux常见命令
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/Linux常用软件/" class="nav-link">
  Linux常用软件
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/docker/" class="nav-link">
  docker
</a></li><li class="dropdown-item"><h4>
          Vim
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/VuePress-blog/文章转载/Vim/vim文章/" class="nav-link">
  vim文章
</a></li><li class="dropdown-subitem"><a href="/VuePress-blog/文章转载/Vim/vim配置/" class="nav-link">
  vim配置
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="常见问题" class="dropdown-title"><span class="title">常见问题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/客户端科学上网/" class="nav-link">
  客户端科学上网
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/命令行科学上网/" class="nav-link">
  命令行科学上网
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/镜像加速大全/" class="nav-link">
  镜像加速大全
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/vim/" class="nav-link">
  vim
</a></li><li class="dropdown-item"><h4>
          Pyhton
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/VuePress-blog/常见问题/Python/" class="nav-link">
  Pyhton
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="python" class="dropdown-title"><span class="title">python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/Python/" class="nav-link">
  首页
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/Python/最新转载/" class="nav-link">
  最新转载
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/Python/爬虫案例/" class="nav-link">
  爬虫案例
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人原创" class="dropdown-title"><span class="title">个人原创</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/个人原创/" class="nav-link">
  个人原创
</a></li></ul></div></div> <a href="https://github.com/solider245/VuePress-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Repo
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章转载" class="dropdown-title"><span class="title">文章转载</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/" class="nav-link">
  首页
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/Linux常见命令/" class="nav-link">
  Linux常见命令
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/Linux常用软件/" class="nav-link">
  Linux常用软件
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/文章转载/docker/" class="nav-link">
  docker
</a></li><li class="dropdown-item"><h4>
          Vim
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/VuePress-blog/文章转载/Vim/vim文章/" class="nav-link">
  vim文章
</a></li><li class="dropdown-subitem"><a href="/VuePress-blog/文章转载/Vim/vim配置/" class="nav-link">
  vim配置
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="常见问题" class="dropdown-title"><span class="title">常见问题</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/客户端科学上网/" class="nav-link">
  客户端科学上网
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/命令行科学上网/" class="nav-link">
  命令行科学上网
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/镜像加速大全/" class="nav-link">
  镜像加速大全
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/常见问题/vim/" class="nav-link">
  vim
</a></li><li class="dropdown-item"><h4>
          Pyhton
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/VuePress-blog/常见问题/Python/" class="nav-link">
  Pyhton
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="python" class="dropdown-title"><span class="title">python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/Python/" class="nav-link">
  首页
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/Python/最新转载/" class="nav-link">
  最新转载
</a></li><li class="dropdown-item"><!----> <a href="/VuePress-blog/Python/爬虫案例/" class="nav-link">
  爬虫案例
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人原创" class="dropdown-title"><span class="title">个人原创</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/VuePress-blog/个人原创/" class="nav-link">
  个人原创
</a></li></ul></div></div> <a href="https://github.com/solider245/VuePress-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Repo
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>docker</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/VuePress-blog/文章转载/docker/Docker Compose保持容器运行.html" class="sidebar-link">Docker Compose保持容器运行</a></li><li><a href="/VuePress-blog/文章转载/docker/Docker 容器镜像及其使用.html" class="sidebar-link">Docker 容器镜像及其使用</a></li><li><a href="/VuePress-blog/文章转载/docker/Docker 构建脚本 Dockerfile 指令全解析.html" class="sidebar-link">Docker 构建脚本 Dockerfile 指令全解析</a></li><li><a href="/VuePress-blog/文章转载/docker/Docker---Dockerfile 详解.html" class="sidebar-link">Docker---Dockerfile 详解</a></li><li><a href="/VuePress-blog/文章转载/docker/Dockerfile 基础实战：构建基础的 ubuntu14.04 镜像.html" class="sidebar-link">Dockerfile 基础实战：构建基础的 ubuntu14.04 镜像</a></li><li><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html" class="active sidebar-link">Dockerfile官方参考</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#用法-🔗" class="sidebar-link">用法 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#buildkit-🔗" class="sidebar-link">BuildKit 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#格式-🔗" class="sidebar-link">格式 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#解析器指令-🔗" class="sidebar-link">解析器指令 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#语法-🔗" class="sidebar-link">语法 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#逃脱-🔗" class="sidebar-link">逃脱 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#更换环境-🔗" class="sidebar-link">更换环境 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#dockerignore文件-🔗" class="sidebar-link">.dockerignore文件 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#来自-🔗" class="sidebar-link">来自 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#运行-🔗" class="sidebar-link">运行 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#cmd-🔗" class="sidebar-link">CMD 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#标签-🔗" class="sidebar-link">标签 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#维护者-（已弃用）-🔗" class="sidebar-link">维护者](#maintainer-deprecated) （已弃用） [🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#暴露-🔗" class="sidebar-link">暴露 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#环保-v" class="sidebar-link">环保 V</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#添加-🔗" class="sidebar-link">添加 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#复制-🔗" class="sidebar-link">复制 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#入口点-🔗" class="sidebar-link">入口点 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#音量-🔗" class="sidebar-link">音量 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#用户-🔗" class="sidebar-link">用户 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#workdir-🔗" class="sidebar-link">WORKDIR 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#arg-🔗" class="sidebar-link">ARG 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#已建-🔗" class="sidebar-link">已建 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#停止-信号🔗" class="sidebar-link">停止 信号🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#健康-检查🔗" class="sidebar-link">健康 检查🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#shell-🔗" class="sidebar-link">SHELL 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#外部实施功能-🔗" class="sidebar-link">外部实施功能 🔗</a></li><li class="sidebar-sub-header"><a href="/VuePress-blog/文章转载/docker/Dockerfile官方参考.html#dockerfile示例-examples" class="sidebar-link">Dockerfile示例 examples</a></li></ul></li><li><a href="/VuePress-blog/文章转载/docker/Dockerfile指令汇总及解析.html" class="sidebar-link">Dockerfile指令汇总及解析</a></li><li><a href="/VuePress-blog/文章转载/docker/Docker开发入门.html" class="sidebar-link">Docker开发入门</a></li><li><a href="/VuePress-blog/文章转载/docker/Dry官方按键备忘.html" class="sidebar-link">Dry官方按键备忘</a></li><li><a href="/VuePress-blog/文章转载/docker/Portainer一个轻量级的Docker环境管理UI.html" class="sidebar-link">Portainer一个轻量级的Docker环境管理UI</a></li><li><a href="/VuePress-blog/%E6%96%87%E7%AB%A0%E8%BD%AC%E8%BD%BD/docker/" aria-current="page" class="sidebar-link">转载docker文章的目录</a></li><li><a href="/VuePress-blog/文章转载/docker/Ubuntu 安装 Docker CE.html" class="sidebar-link">Ubuntu 安装 Docker CE</a></li><li><a href="/VuePress-blog/文章转载/docker/docker-Compose官方教程.html" class="sidebar-link">docker-Compose官方教程</a></li><li><a href="/VuePress-blog/文章转载/docker/docker运行shell脚本问题.html" class="sidebar-link">docker运行shell脚本问题</a></li><li><a href="/VuePress-blog/文章转载/docker/mac 下使用 Docker 搭建 ubuntu 环境.html" class="sidebar-link">mac 下使用 Docker 搭建 ubuntu 环境</a></li><li><a href="/VuePress-blog/文章转载/docker/一个node入门Dockfile.html" class="sidebar-link">一个node入门Dockfile</a></li><li><a href="/VuePress-blog/文章转载/docker/不正宗 docker 入门教程-构建一个镜像.html" class="sidebar-link">不正宗 docker 入门教程-构建一个镜像</a></li><li><a href="/VuePress-blog/文章转载/docker/从镜像历史记录逆向分析出Dockerfile.html" class="sidebar-link">从镜像历史记录逆向分析出Dockerfile</a></li><li><a href="/VuePress-blog/文章转载/docker/使用 BuildKit 构建镜像.html" class="sidebar-link">使用 BuildKit 构建镜像</a></li><li><a href="/VuePress-blog/文章转载/docker/借助Dockerize更好的Docker体验.html" class="sidebar-link">借助Dockerize更好的Docker体验</a></li><li><a href="/VuePress-blog/文章转载/docker/在Dockerfile中运行脚本.html" class="sidebar-link">在Dockerfile中运行脚本</a></li><li><a href="/VuePress-blog/文章转载/docker/如何在Ubuntu 16.04上以干式方式管理和监视Docker容器.html" class="sidebar-link">如何在Ubuntu 16.04上以干式方式管理和监视Docker容器</a></li><li><a href="/VuePress-blog/文章转载/docker/如何在Ubuntu 20.04 LTS上使用Dockerfile创建Docker映像.html" class="sidebar-link">如何在Ubuntu 20.04 LTS上使用Dockerfile创建Docker映像</a></li><li><a href="/VuePress-blog/文章转载/docker/如何编写最佳的Dockerfile.html" class="sidebar-link">如何编写最佳的Dockerfile</a></li><li><a href="/VuePress-blog/文章转载/docker/官方下一代Docker镜像构建神器 -- BuildKit.html" class="sidebar-link">官方下一代Docker镜像构建神器 -- BuildKit</a></li><li><a href="/VuePress-blog/文章转载/docker/对传统应用进行容器化改造（译）.html" class="sidebar-link">对传统应用进行容器化改造（译）</a></li><li><a href="/VuePress-blog/文章转载/docker/应用容器化&amp;DevOps之路.html" class="sidebar-link">应用容器化&amp;DevOps之路</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#用法-🔗-usage">用法 🔗</a></li><li><a href="#buildkit-🔗-buildkit">BuildKit 🔗</a></li><li><a href="#格式-🔗-format">格式 🔗</a></li><li><a href="#解析器指令-🔗-parser-directives">解析器指令 🔗</a></li><li><a href="#语法-🔗-syntax">语法 🔗</a><ul><li><a href="#官方发布-🔗-official-releases">官方发布 🔗</a></li></ul></li><li><a href="#逃脱-🔗-escape">逃脱 🔗</a></li><li><a href="#更换环境-🔗-environment-replacement">更换环境 🔗</a></li><li><a href="#dockerignore文件-🔗-dockerignore-file">.dockerignore文件 🔗</a></li><li><a href="#来自-🔗-from">来自 🔗</a><ul><li><a href="#了解arg和from之间的交互方式-🔗-understand-how-arg-and-from-interact">了解ARG和FROM之间的交互方式 🔗</a></li></ul></li><li><a href="#运行-🔗-run">运行 🔗</a><ul><li><a href="#已知问题（运行）-🔗-known-issues-run">已知问题（运行） 🔗</a></li></ul></li><li><a href="#cmd-🔗-cmd">CMD 🔗</a></li><li><a href="#标签-🔗-label">标签 🔗</a></li><li><a href="#维护者-maintainer-deprecated-（已弃用）-🔗-maintainer-deprecated">维护者](#maintainer-deprecated) （已弃用） [🔗</a></li><li><a href="#暴露-🔗-expose">暴露 🔗</a></li><li><a href="#环保-v-env">环保 V</a></li><li><a href="#添加-🔗-add">添加 🔗</a></li><li><a href="#复制-🔗-copy">复制 🔗</a></li><li><a href="#入口点-🔗-entrypoint">入口点 🔗</a><ul><li><a href="#执行表格entrypoint示例-🔗-exec-form-entrypoint-example">执行表格ENTRYPOINT示例 🔗</a></li><li><a href="#外壳形式entrypoint示例-example-shell-form-entrypoint-example">外壳形式ENTRYPOINT示例 example</a></li><li><a href="#了解cmd和entrypoint如何相互作用-🔗-understand-how-cmd-and-entrypoint-interact">了解CMD和ENTRYPOINT如何相互作用 🔗</a></li></ul></li><li><a href="#音量-🔗-volume">音量 🔗</a><ul><li><a href="#有关指定卷的注意事项-🔗-notes-about-specifying-volumes">有关指定卷的注意事项 🔗</a></li></ul></li><li><a href="#用户-🔗-user">用户 🔗</a></li><li><a href="#workdir-🔗-workdir">WORKDIR 🔗</a></li><li><a href="#arg-🔗-arg">ARG 🔗</a><ul><li><a href="#默认值-🔗-default-values">默认值 🔗</a></li><li><a href="#范围-🔗-scope">范围 🔗</a></li><li><a href="#使用arg变量-🔗-using-arg-variables">使用ARG变量 🔗</a></li><li><a href="#预定义的-args🔗-predefined-args">预定义的 ARGs🔗</a></li><li><a href="#全球范围内的自动平台-args🔗-automatic-platform-args-in-the-global-scope">全球范围内的自动平台 ARGs🔗</a></li><li><a href="#对构建缓存的影响-🔗-impact-on-build-caching">对构建缓存的影响 🔗</a></li></ul></li><li><a href="#已建-🔗-onbuild">已建 🔗</a></li><li><a href="#停止-信号🔗-stopsignal">停止 信号🔗</a></li><li><a href="#健康-检查🔗-healthcheck">健康 检查🔗</a></li><li><a href="#shell-🔗-shell">SHELL 🔗</a></li><li><a href="#外部实施功能-🔗-external-implementation-features">外部实施功能 🔗</a></li><li><a href="#dockerfile示例-examples-dockerfile-examples">Dockerfile示例 examples</a></li></ul></div>
Docker可以通过阅读Docker的指令来自动构建映像 <code>Dockerfile</code> 。 A <code>Dockerfile</code> 是一个文本文档，其中包含用户可以在命令行上调用以组装图像的所有命令。 使用 <code>docker build</code> 用户可以创建一个自动构建，该构建连续执行多个命令行指令。<p></p> <p>本页描述您可以在中使用的命令 <code>Dockerfile</code> 。 阅读完此页面后，请参考 <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer"><code>Dockerfile</code>最佳实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 以获取有关技巧的指南。</p> <h2 id="用法-🔗">用法 <a href="#usage">🔗</a></h2> <p>的 <a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener noreferrer">搬运工构建<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 命令从一个构建的图像 <code>Dockerfile</code> 和一个 <em>上下文</em> 。 构建的上下文是指定位置 <code>PATH</code> 或 的文件集 <code>URL</code> 。 这 <code>PATH</code> 是本地文件系统上的目录。 该 <code>URL</code> 是一个Git仓库的位置。</p> <p>上下文是递归处理的。 因此，a <code>PATH</code> 包括任何子目录，并且 a 包括 <code>URL</code> 存储库及其子模块。 此示例显示了一个使用当前目录作为上下文的构建命令：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build .

Sending build context to Docker daemon  6.51 MB
...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>构建是由Docker守护程序而不是CLI运行的。 生成过程要做的第一件事是将整个上下文（递归）发送到守护程序。 在大多数情况下，最好从空目录开始作为上下文，并将Dockerfile保留在该目录中。 仅添加构建Dockerfile所需的文件。</p> <blockquote><p><strong>警告</strong></p> <p>不要用你的根目录下， <code>/</code> 作为 <code>PATH</code> 因为它会导致生成到您的硬盘驱动器的全部内容传输到码头工人守护进程。</p></blockquote> <p>要在构建上下文中使用文件， <code>Dockerfile</code> 引用是指指令（例如， <code>COPY</code> 指令）中 指定的文件 。 要提高构建的性能，请通过将 <code>.dockerignore</code> 文件 添加 到上下文目录来 排除文件和 目录。 有关如何 <a href="#dockerignore-file">创建 <code>.dockerignore</code> 文件的信息，</a> 请参阅此页面上的文档。</p> <p>传统上， <code>Dockerfile</code> 称为 <code>Dockerfile</code> 并位于上下文的根中。 您可以使用 <code>-f</code> 标志with <code>docker build</code> 指向文件系统中任何位置的Dockerfile。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build -f /path/to/a/Dockerfile .

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果构建成功，则可以指定一个存储库和标记，用于在其中存储新图像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build -t shykes/myapp .

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要在构建后将映像标记到多个存储库中，请在 <code>-t</code> 运行 <code>build</code> 命令 时 添加多个 参数 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在Docker守护程序运行中的指令之前 <code>Dockerfile</code> ，它 会对 进行初步验证， <code>Dockerfile</code> 如果语法不正确，则返回错误：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build -t test/myapp .

Sending build context to Docker daemon 2.048 kB
Error response from daemon: Unknown instruction: RUNCMD

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Docker守护程序以 <code>Dockerfile</code> 一对一的方式 运行指令， 如有必要，将每条指令的结果提交到新映像，然后最终输出新映像的ID。 Docker守护程序将自动清理您发送的上下文。</p> <p>请注意，每条指令都是独立运行的，并会导致创建新映像-因此 <code>RUN cd /tmp</code> 对下一条指令不会有任何影响。</p> <p>Docker将尽可能重用中间映像（缓存），以 <code>docker build</code> 显着 加速该 过程。 这由 <code>Using cache</code> 控制台输出中 的 消息 指示 。 （有关详细信息，请参阅 <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer"><code>Dockerfile</code>最佳做法指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build -t svendowideit/ambassador .

Sending build context to Docker daemon 15.36 kB
Step 1/4 : FROM alpine:3.2
 ---&gt; 31f630c65071
Step 2/4 : MAINTAINER SvenDowideit@home.org.au
 ---&gt; Using cache
 ---&gt; 2a1c91448f5f
Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/
 ---&gt; Using cache
 ---&gt; 21ed6e7fbb73
Step 4/4 : CMD env | grep _TCP= | (sed 's/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/' &amp;&amp; echo wait) | sh
 ---&gt; Using cache
 ---&gt; 7ea8aef582cc
Successfully built 7ea8aef582cc

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>构建缓存仅用于具有本地父链的映像。 这意味着这些图像是由以前的版本创建的，或者整个图像链都已加载 <code>docker load</code> 。 如果您希望使用特定映像的构建缓存，则可以使用 <code>--cache-from</code> 选项 指定它 。 指定的图像 <code>--cache-from</code> 不需要具有父链，并且可以从其他注册表中提取。</p> <p>完成构建后，就可以开始研究 <a href="https://docs.docker.com/engine/tutorials/dockerrepos/#/contributing-to-docker-hub" target="_blank" rel="noopener noreferrer"><em>将存储库推送到其注册表了</em><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <h2 id="buildkit-🔗">BuildKit <a href="#buildkit">🔗</a></h2> <p>从版本18.09开始，Docker支持由 <a href="https://github.com/moby/buildkit" target="_blank" rel="noopener noreferrer">moby / buildkit<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 项目 提供的用于执行构建的新后端 。 与旧的实现相比，BuildKit后端提供了许多好处。 例如，BuildKit可以：</p> <ul><li>检测并跳过执行未使用的构建阶段</li> <li>并行构建独立构建阶段</li> <li>两次构建之间仅增量传输构建上下文中的更改文件</li> <li>在构建上下文中检测并跳过传输未使用的文件</li> <li>使用具有许多新功能的外部Dockerfile实现</li> <li>避免与其他API产生副作用（中间图像和容器）</li> <li>优先考虑构建缓存以进行自动修剪</li></ul> <p>要使用BuildKit后端，您需要 <code>DOCKER_BUILDKIT=1</code> 在CLI上 设置环境变量 ，然后再调用 <code>docker build</code> 。</p> <p>要了解基于BuildKit的构建可用的实验性Dockerfile语法， <a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md" target="_blank" rel="noopener noreferrer">请参阅BuildKit存储库中的文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <h2 id="格式-🔗">格式 <a href="#format">🔗</a></h2> <p>这是的格式 <code>Dockerfile</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># Comment
INSTRUCTION arguments

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>该指令不区分大小写。 但是，约定将它们大写，以便更轻松地将它们与参数区分开。</p> <p>Docker <code>Dockerfile</code> 按顺序 运行指令 。 一个 <code>Dockerfile</code> <strong>必须以开始<code>FROM</code>的指令</strong> 。 这可能在 <a href="#parser-directives">解析器指令</a> ， <a href="#format">注释</a> 和全局范围的 <a href="#arg">ARG之后</a> 。 该 <code>FROM</code> 指令指定 要从中构建 <a href="https://docs.docker.com/glossary/#parent_image" target="_blank" rel="noopener noreferrer"><em>父图像</em><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。 <code>FROM</code> 只能在一个或多个 <code>ARG</code> 指令之后，这些指令声明在中的 <code>FROM</code> 行中 使用的参数 <code>Dockerfile</code> 。</p> <p>该码头工人对待线 <em>开始</em> 以 <code>#</code> 作为注释，除非该行是一个有效的 <a href="#parser-directives">解析器指令</a> 。 <code>#</code> 一行中其他任何地方 的 标记都被视为参数。 这允许如下语句：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># Comment
RUN echo 'we are running some # of cool things'

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在执行Dockerfile指令之前删除注释行，这意味着以下示例中的注释不会由执行 <code>echo</code> 命令 的Shell处理 ，并且以下两个示例是等效的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN echo hello \
# comment
world

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>RUN echo hello \
world

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注释中不支持换行符。</p> <blockquote><p><strong>注意空白</strong></p> <p>为了向后兼容， 将忽略但不鼓励 在注释（ <code>#</code> ）和指令（例如 <code>RUN</code> ） 之前的前导空白 。 在这些情况下，不保留前导空格，因此以下示例是等效的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>        # this is a comment-line
    RUN echo hello
RUN echo world

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code># this is a comment-line
RUN echo hello
RUN echo world

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但是请注意，指令 <em>参数</em> 中的空格 （例如跟随其后的命令 <code>RUN</code> ）被保留，因此以下示例使用指定的前导空格打印“ hello world”：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN echo &quot;\
     hello\
     world&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></blockquote> <h2 id="解析器指令-🔗">解析器指令 <a href="#parser-directives">🔗</a></h2> <p>解析器指令是可选的，并且会影响 <code>Dockerfile</code> 处理 a 中 后续行的 方式。 解析器指令不会在构建中添加层，也不会显示为构建步骤。 解析器指令以形式写为特殊类型的注释 <code># directive=value</code> 。 单个指令只能使用一次。</p> <p>处理完注释，空行或生成器指令后，Docker不再寻找解析器指令。 而是将格式化为解析器指令的任何内容都视为注释，并且不会尝试验证它是否可能是解析器指令。 因此，所有解析器指令必须位于的最顶部 <code>Dockerfile</code> 。</p> <p>解析器指令不区分大小写。 但是，约定是小写的。 约定还应在任何解析器指令之后包含一个空白行。 解析器伪指令不支持行继续字符。</p> <p>由于这些规则，以下示例均无效：</p> <p>由于行继续而无效：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># direc \
tive=value

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>由于出现两次而无效：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># directive=value1
# directive=value2

FROM ImageName

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于出现在构建器指令之后而被视为注释：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ImageName
# directive=value

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>由于出现在不是解析器指令的注释之后，因此被视为注释：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># About my dockerfile
# directive=value
FROM ImageName

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>由于未被识别，未知指令被视为注释。 此外，由于在非解析程序指令的注释之后出现，因此已知指令被视为注释。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># unknowndirective=value
# knowndirective=value

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>解析器指令中允许非换行空格。 因此，以下各行均被相同对待：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#directive=value
# directive =value
#	directive= value
# directive = value
#	  dIrEcTiVe=value

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>支持以下解析器指令：</p> <ul><li><code>syntax</code></li> <li><code>escape</code></li></ul> <h2 id="语法-🔗">语法 <a href="#syntax">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code># syntax=[remote image reference]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># syntax=docker/dockerfile
# syntax=docker/dockerfile:1.0
# syntax=docker.io/docker/dockerfile:1
# syntax=docker/dockerfile:1.0.0-experimental
# syntax=example.com/user/repo:tag@sha256:abcdef...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>仅当使用 <a href="#buildkit">BuildKit</a> 后端 时才启用此功能 。</p> <p>语法指令定义用于构建当前Dockerfile的Dockerfile构建器的位置。 BuildKit后端允许无缝使用构建器的外部实现，这些构建器以Docker映像的形式分发并在容器沙箱环境中执行。</p> <p>自定义Dockerfile实现使您能够：</p> <ul><li>自动获取错误修正，无需更新守护程序</li> <li>确保所有用户都使用相同的实现来构建您的Dockerfile</li> <li>使用最新功能而不更新守护程序</li> <li>试用新的实验性或第三方功能</li></ul> <h3 id="官方发布-🔗">官方发布 <a href="#official-releases">🔗</a></h3> <p>Docker分发映像的正式版本，这些映像可用于 <code>docker/dockerfile</code> 在Docker Hub上的存储库 下构建Dockerfile 。 有两个发布新图像的渠道：稳定版和实验版。</p> <p>稳定的通道遵循语义版本控制。 例如：</p> <ul><li><code>docker/dockerfile:1.0.0</code> -仅允许不可变版本 <code>1.0.0</code></li> <li><code>docker/dockerfile:1.0</code> -允许版本 <code>1.0.*</code></li> <li><code>docker/dockerfile:1</code> -允许版本 <code>1.*.*</code></li> <li><code>docker/dockerfile:latest</code> -稳定频道上的最新版本</li></ul> <p>在发布时，实验频道使用稳定版本中主要和次要组件的增量版本控制。 例如：</p> <ul><li><code>docker/dockerfile:1.0.1-experimental</code> -仅允许不可变版本 <code>1.0.1-experimental</code></li> <li><code>docker/dockerfile:1.0-experimental</code> -之后的最新实验版本 <code>1.0</code></li> <li><code>docker/dockerfile:experimental</code> -实验频道的最新版本</li></ul> <p>您应该选择最适合自己需求的渠道。 如果您只想修正错误，则应使用 <code>docker/dockerfile:1.0</code> 。 如果您想从实验功能中受益，则应使用实验频道。 如果您正在使用实验性频道，则较新的版本可能无法向后兼容，因此建议使用不可变的完整版本。</p> <p>有关主版本和每晚发布的功能，请参考 <a href="https://github.com/moby/buildkit/blob/master/README.md" target="_blank" rel="noopener noreferrer">源存储库中<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的描述 。</p> <h2 id="逃脱-🔗">逃脱 <a href="#escape">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code># escape=\ (backslash)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要么</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># escape=` (backtick)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>escape</code> 指令设置用来逃避的字符的字符 <code>Dockerfile</code> 。 如果未指定，则默认转义字符为 <code>\</code> 。</p> <p>转义字符用于转义一行中的字符和转义换行符。 这允许一条 <code>Dockerfile</code> 指令跨越多行。 请注意，无论 <code>escape</code> parser指令是否包含在 <code>Dockerfile</code> ， <em>都不会在<code>RUN</code>命令中执行转义，除非在行末。</em></p> <p>将转义符设置 <code>`</code> 为尤其有用 <code>Windows</code> ，其中 <code>\</code> 目录路径分隔符为。 <code>`</code> 与 <a href="https://technet.microsoft.com/en-us/library/hh847755.aspx" target="_blank" rel="noopener noreferrer">Windows PowerShell<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 一致 。</p> <p>考虑以下示例，该示例将以非显而易见的方式失败 <code>Windows</code> 。 第二 <code>\</code> ，在第二行的端部将被解释为用于换行的逃逸，而不是从第一逸出的目标 <code>\</code> 。 类似地， <code>\</code> 假设第三行的末尾实际上被当作一条指令来处理，则将其视为行的继续。 该dockerfile的结果是第二和第三行被视为一条指令：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM microsoft/nanoserver
COPY testfile.txt c:\\
RUN dir c:\

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>结果是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>PS C:\John&gt; docker build -t cmd .
Sending build context to Docker daemon 3.072 kB
Step 1/2 : FROM microsoft/nanoserver
 ---&gt; 22738ff49c6d
Step 2/2 : COPY testfile.txt c:\RUN dir c:
GetFileAttributesEx c:RUN: The system cannot find the file specified.
PS C:\John&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上述解决方案之一是将 和和 <code>/</code> 用作目标 。 但是，这种语法充其量是令人困惑的，因为它对上的路径来说并不自然 ，而在最坏的情况下，由于并非所有 支持的 命令都 作为路径分隔符 ，因此容易出错 。 <code>COPY</code> <code>dir</code> <code>Windows</code> <code>Windows</code> <code>/</code></p> <p>通过添加 <code>escape</code> 解析器指令，通过对以下 <code>Dockerfile</code> 文件路径使用自然平台语义 ，以下操作可以 按预期成功 <code>Windows</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># escape=`

FROM microsoft/nanoserver
COPY testfile.txt c:\
RUN dir c:\

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>结果是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>PS C:\John&gt; docker build -t succeeds --no-cache=true .
Sending build context to Docker daemon 3.072 kB
Step 1/3 : FROM microsoft/nanoserver
 ---&gt; 22738ff49c6d
Step 2/3 : COPY testfile.txt c:\
 ---&gt; 96655de338de
Removing intermediate container 4db9acbb1682
Step 3/3 : RUN dir c:\
 ---&gt; Running in a2c157f842f5
 Volume in drive C has no label.
 Volume Serial Number is 7E6D-E0F7

 Directory of c:\

10/05/2016  05:04 PM             1,894 License.txt
10/05/2016  02:22 PM    &lt;DIR&gt;          Program Files
10/05/2016  02:14 PM    &lt;DIR&gt;          Program Files (x86)
10/28/2016  11:18 AM                62 testfile.txt
10/28/2016  11:20 AM    &lt;DIR&gt;          Users
10/28/2016  11:20 AM    &lt;DIR&gt;          Windows
           2 File(s)          1,956 bytes
           4 Dir(s)  21,259,096,064 bytes free
 ---&gt; 01c7f3bef04f
Removing intermediate container a2c157f842f5
Successfully built 01c7f3bef04f
PS C:\John&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="更换环境-🔗">更换环境 <a href="#environment-replacement">🔗</a></h2> <p>环境变量（与声明 <a href="#env">的 <code>ENV</code> 声明</a> ），也可以在特定指令作为变量用来被解释 <code>Dockerfile</code> 。 转义也可以通过将类变量的语法包括在语句中而得到处理。</p> <p>环境变量 <code>Dockerfile</code> 用 <code>$variable_name</code> 或表示 <code>${variable_name}</code> 。 它们被同等对待，并且大括号语法通常用于解决变量名没有空格的问题，例如 <code>${foo}_bar</code> 。</p> <p>该 <code>${variable_name}</code> 语法还支持以下一些标准 <code>bash</code> 修饰符：</p> <ul><li><code>${variable:-word}</code> 表示如果 <code>variable</code> 设置，则结果将是该值。 如果 <code>variable</code> 未设置，则为 <code>word</code> 结果。</li> <li><code>${variable:+word}</code> 指示如果 <code>variable</code> 设置 了if，则将 是 <code>word</code> 结果，否则结果为空字符串。</li></ul> <p>在所有情况下， <code>word</code> 都可以是任何字符串，包括其他环境变量。</p> <p>可通过 <code>\</code> 在变量前 添加a来 进行 转义 ： 例如， <code>\$foo</code> 或 <code>\${foo}</code> 将 分别 转换为 <code>$foo</code> 和 <code>${foo}</code> 文字。</p> <p>示例（解析的表示形式显示在之后 <code>#</code> ）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar
ADD . $foo       # ADD . /bar
COPY \$foo /quux # COPY $foo /quux

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>以下变量中的指令列表支持环境变量 <code>Dockerfile</code> ：</p> <ul><li><code>ADD</code></li> <li><code>COPY</code></li> <li><code>ENV</code></li> <li><code>EXPOSE</code></li> <li><code>FROM</code></li> <li><code>LABEL</code></li> <li><code>STOPSIGNAL</code></li> <li><code>USER</code></li> <li><code>VOLUME</code></li> <li><code>WORKDIR</code></li> <li><code>ONBUILD</code> （当与以上支持的说明之一结合使用时）</li></ul> <p>在整个指令中，环境变量替换将对每个变量使用相同的值。 换句话说，在此示例中：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV abc=hello
ENV abc=bye def=$abc
ENV ghi=$abc

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>将导致 <code>def</code> 值为 <code>hello</code> ，而不是 <code>bye</code> 。 但是， <code>ghi</code> 将具有的值， <code>bye</code> 因为它不是设置 <code>abc</code> 为 的同一指令的一部分 <code>bye</code> 。</p> <h2 id="dockerignore文件-🔗">.dockerignore文件 <a href="#dockerignore-file">🔗</a></h2> <p>在docker CLI将上下文发送到docker守护程序之前，它会 <code>.dockerignore</code> 在上下文的根目录中 查找名为的文件 。 如果此文件存在，则CLI会修改上下文以排除与其中的模式匹配的文件和目录。 这有助于避免不必要地将大型文件或敏感文件和目录发送到守护程序，并避免使用 <code>ADD</code> 或 将它们添加到映像中 <code>COPY</code> 。</p> <p>CLI将 <code>.dockerignore</code> 文件 解释 为以换行符分隔的模式列表，类似于Unix Shell的文件组。 为了匹配，上下文的根被认为是工作目录和根目录。 例如，图案 <code>/foo/bar</code> 和 <code>foo/bar</code> 两个排除命名的文件或目录 <code>bar</code> 的 <code>foo</code> 子目录 <code>PATH</code> 或位于Git仓库的根 <code>URL</code> 。 都不排除其他任何东西。</p> <p>如果 <code>.dockerignore</code> 文件中 的一行以第 <code>#</code> 1列 开头 ，则该行将被视为注释，并且在CLI解释之前将被忽略。</p> <p>这是一个示例 <code>.dockerignore</code> 文件：</p> <div class="language-gitignore line-numbers-mode"><pre class="language-text"><code># comment
*/temp*
*/*/temp*
temp?

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>此文件导致以下生成行为：</p> <table><thead><tr><th>规则</th> <th>行为</th></tr></thead> <tbody><tr><td><code># comment</code></td> <td>忽略了。</td></tr> <tr><td><code>*/temp*</code></td> <td>排除名称以 <code>temp</code> 根的任何直接子目录 开头的文件和目录 。 例如， <code>/somedir/temporary.txt</code> 排除 纯文件 ，排除目录 <code>/somedir/temp</code> 。</td></tr> <tr><td><code>*/*/temp*</code></td> <td>排除 <code>temp</code> 从根以下两个级别的任何子目录 开始的文件和目录 。 例如， <code>/somedir/subdir/temporary.txt</code> 被排除。</td></tr> <tr><td><code>temp?</code></td> <td>排除名称为的一个字符扩展名的根目录中的文件和目录 <code>temp</code> 。 例如， <code>/tempa</code> 和 <code>/tempb</code> 被排除。</td></tr></tbody></table> <p>使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener noreferrer">filepath.Match<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 规则 进行匹配 。 预处理步骤 使用Go的 <a href="http://golang.org/pkg/path/filepath/#Clean" target="_blank" rel="noopener noreferrer">filepath.Clean<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 除去开头和结尾的空格，并消除 <code>.</code> 和 <code>..</code> 元素 。 预处理后空白的行将被忽略。<a href="http://golang.org/pkg/path/filepath/#Clean" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>除了Go的filepath.Match规则外，Docker还支持一个特殊的通配符字符串 <code>**</code> ，该 字符串 可匹配任意数量的目录（包括零个）。 例如， <code>**/*.go</code> 将排除 <code>.go</code> 在所有目录（包括构建上下文的根目录）中找到的所有 结尾的文件 。</p> <p>以 <code>!</code> （感叹号） 开头的行 可用于排除例外。 以下是 <code>.dockerignore</code> 使用此机制 的示例 文件：</p> <div class="language-gitignore line-numbers-mode"><pre class="language-text"><code>*.md
!README.md

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><em>除</em> <code>README.md</code> 上下文<em>外</em> ， 所有降价文件 都排除在外。</p> <p><code>!</code> 异常规则 的位置会 影响行为： <code>.dockerignore</code> 匹配特定文件的 的最后一行 确定是包含还是排除该文件。 考虑以下示例：</p> <div class="language-gitignore line-numbers-mode"><pre class="language-text"><code>*.md
!README*.md
README-secret.md

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>除了以外的自述文件，上下文中没有markdown文件 <code>README-secret.md</code> 。</p> <p>现在考虑以下示例：</p> <div class="language-gitignore line-numbers-mode"><pre class="language-text"><code>*.md
README-secret.md
!README*.md

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>包括所有自述文件。 中线无效，因为 <code>!README*.md</code> 匹配 <code>README-secret.md</code> 并排在最后。</p> <p>您甚至可以使用该 <code>.dockerignore</code> 文件排除 <code>Dockerfile</code> 和 <code>.dockerignore</code> 文件。 这些文件仍被发送到守护程序，因为它需要它们来完成其工作。 但是 <code>ADD</code> 和 <code>COPY</code> 指令不会将它们复制到映像中。</p> <p>最后，您可能想要指定要包含在上下文中的文件，而不是要排除的文件。 为此，请指定 <code>*</code> 为第一个模式，然后 指定 一个或多个 <code>!</code> 异常模式。</p> <blockquote><p><strong>注意</strong></p> <p>由于历史原因，该模式 <code>.</code> 被忽略。</p></blockquote> <h2 id="来自-🔗">来自 <a href="#from">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要么</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要么</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>FROM</code> 指令初始化一个新的构建阶段，并 为后续指令 设置 <a href="https://docs.docker.com/glossary/#base_image" target="_blank" rel="noopener noreferrer"><em>基本映像</em><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。 因此，有效的 <code>Dockerfile</code> 必须从 <code>FROM</code> 指令 开始 。 该图像可以是任何有效图像- 从<a href="https://docs.docker.com/engine/tutorials/dockerrepos/" target="_blank" rel="noopener noreferrer"><em>公共存储库中</em><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><strong>拉出图像</strong> 特别容易启动 。<a href="https://docs.docker.com/engine/tutorials/dockerrepos/" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><code>ARG</code> 是先于仅指示 <code>FROM</code> 在 <code>Dockerfile</code> 。 请参阅 <a href="#understand-how-arg-and-from-interact">了解ARG和FROM之间的相互作用</a> 。</li> <li><code>FROM</code> 可以一次出现多次 <code>Dockerfile</code> 以创建多个映像，也可以将一个构建阶段作为对另一个构建阶段的依赖。 只需在每个新 <code>FROM</code> 指令 之前记录一次提交输出的最后一个图像ID 。 每个 <code>FROM</code> 指令清除由先前指令创建的任何状态。</li> <li>可选的名称可以通过添加给予一个新的构建阶段 <code>AS name</code> 的 <code>FROM</code> 指令。 该名称可以在后续版本 <code>FROM</code> 和 <code>COPY --from=&lt;name|index&gt;</code> 说明中 使用， 以引用此阶段中构建的映像。</li> <li>该 <code>tag</code> 或 <code>digest</code> 值是可选的。 如果您忽略其中任何一个 <code>latest</code> ，那么缺省情况下 ，构建器将采用 标签。 如果构建器找不到该 <code>tag</code> 值， 则返回错误 。</li></ul> <p><code>--platform</code> 在 <code>FROM</code> 引用多平台图像的 情况下 ，可选 标志可用于指定图像 的平台。 例如， <code>linux/amd64</code> ， <code>linux/arm64</code> ，或 <code>windows/amd64</code> 。 默认情况下，使用构建请求的目标平台。 可以在此标志的值中使用全局构建参数，例如， <a href="#automatic-platform-args-in-the-global-scope">自动平台ARG</a> 允许您将阶段强制到本机构建平台（ <code>--platform=$BUILDPLATFORM</code> ），并使用它来交叉编译到阶段内部的目标平台。</p> <h3 id="了解arg和from之间的交互方式-🔗">了解ARG和FROM之间的交互方式 <a href="#understand-how-arg-and-from-interact">🔗</a></h3> <p><code>FROM</code> 指令支持由 <code>ARG</code> 第一指令之前的 任何 指令 声明的变量 <code>FROM</code> 。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app

FROM extras:${CODE_VERSION}
CMD  /code/run-extras

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>ARG</code> 在a之前 的 声明 <code>FROM</code> 位于构建阶段之外，因此在a之后的任何指令中都不能使用它 <code>FROM</code> 。 要 <code>ARG</code> 在第一次 <code>FROM</code> 使用 声明之前 使用默认值，请 在 <code>ARG</code> 构建阶段 使用 没有值 的 指令：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ARG VERSION=latest
FROM busybox:$VERSION
ARG VERSION
RUN echo $VERSION &gt; image_version

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="运行-🔗">运行 <a href="#run">🔗</a></h2> <p>RUN有2种形式：</p> <ul><li><code>RUN &lt;command&gt;</code> （ <em>shell</em> 形式，命令在shell中运行，默认情况下 <code>/bin/sh -c</code> 在Linux或 <code>cmd /S /C</code> Windows 上运行 ）</li> <li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> （ <em>执行</em> 表格）</li></ul> <p>该 <code>RUN</code> 指令将在当前图像顶部的新层中执行所有命令，并提交结果。 生成的提交图像将用于中的下一步 <code>Dockerfile</code> 。</p> <p>分层 <code>RUN</code> 指令和生成提交符合Docker的核心概念，在Docker上，提交很便宜，并且可以从映像历史记录的任何位置创建容器，就像源代码控制一样。</p> <p>在 <em>EXEC</em> 形式使得能够避免壳串改写（munging），并 <code>RUN</code> 使用不包含指定壳可执行基本图像的命令。</p> <p>可以使用以下 命令 更改 <em>shell</em> 形式 的默认shell <code>SHELL</code> 。</p> <p>在 <em>shell</em> 形式中，您可以使用 <code>\</code> （反斜杠）将一条RUN指令继续到下一行。 例如，考虑以下两行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN /bin/bash -c 'source $HOME/.bashrc; \
echo $HOME'

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>它们合起来相当于以下一行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要使用'/ bin / sh'以外的其他shell，请使用 <em>exec</em> 形式传入所需的shell。 例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p><strong>注意</strong></p> <p>在 <em>EXEC</em> 形式被解析为一个JSON阵列，这意味着必须使用双引号（“）周围的话不单引号（'）。</p></blockquote> <p>与 <em>shell</em> 表单 不同 ， <em>exec</em> 表单不会调用命令shell。 这意味着不会发生常规的外壳处理。 例如， <code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code> 将不会对进行变量替换 <code>$HOME</code> 。 如果要进行shell处理，则可以使用 <em>shell</em> 形式或直接执行shell，例如： <code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code> 。 当使用exec表单并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。</p> <blockquote><p><strong>注意</strong></p> <p>在 <em>JSON</em> 格式中，必须转义反斜杠。 这在Windows中特别有用，在Windows中反斜杠是路径分隔符。 由于无效的JSON， 以下行否则将被视为 <em>shell</em> 形式，并以意外的方式失败：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>此示例的正确语法为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <p><code>RUN</code> 下一次构建期间 ， 指令 缓存 不会自动失效。 类似指令的缓存 <code>RUN apt-get dist-upgrade -y</code> 将在下一个构建中重用。 <code>RUN</code> 指令 的缓存 可以通过使用 <code>--no-cache</code> 标志 来使无效 ，例如 <code>docker build --no-cache</code> 。</p> <p>有关 更多信息， 请参见 <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer"><code>Dockerfile</code>最佳实践指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <p><code>RUN</code> 指令 的缓存 可以被 <a href="#add"><code>ADD</code></a> 和 <a href="#copy"><code>COPY</code></a> 指令 无效 。</p> <h3 id="已知问题（运行）-🔗">已知问题（运行） <a href="#known-issues-run">🔗</a></h3> <ul><li><p><a href="https://github.com/docker/docker/issues/783" target="_blank" rel="noopener noreferrer">问题783<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是有关使用AUFS文件系统时可能发生的文件权限问题。 例如，您在尝试 <code>rm</code> 文件 过程中可能会注意到它 。</p> <p>对于具有最新aufs版本的系统（即， <code>dirperm1</code> 可以设置安装选项），docker将尝试通过使用options挂载层来尝试自动修复问题 <code>dirperm1</code> 。 有关 <code>dirperm1</code> 选项的 更多详细信息，请 参见 <a href="https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs" target="_blank" rel="noopener noreferrer"><code>aufs</code>手册页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>如果您的系统不支持 <code>dirperm1</code> ，则该问题描述了一种解决方法。</p></li></ul> <h2 id="cmd-🔗">CMD <a href="#cmd">🔗</a></h2> <p>该 <code>CMD</code> 指令具有三种形式：</p> <ul><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> （ <em>exec</em> 形式，这是首选形式）</li> <li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> （作为 <em>ENTRYPOINT的默认参数</em> ）</li> <li><code>CMD command param1 param2</code> （ <em>外壳</em> 形式）</li></ul> <p><code>CMD</code> 指令中 只能有一条 指令 <code>Dockerfile</code> 。 如果您列出多个， <code>CMD</code> 则只有最后一个 <code>CMD</code> 才会生效。</p> <p><strong>a的主要目的<code>CMD</code>是为执行中的容器提供默认值。</strong> 这些默认值可以包含一个可执行文件，也可以忽略该可执行文件，在这种情况下，您还必须指定一条 <code>ENTRYPOINT</code> 指令。</p> <p>如果 <code>CMD</code> 用于为 <code>ENTRYPOINT</code> 指令 提供默认参数 ，则 <code>CMD</code> 和 <code>ENTRYPOINT</code> 指令均应使用JSON数组格式指定。</p> <blockquote><p><strong>注意</strong></p> <p>在 <em>EXEC</em> 形式被解析为一个JSON阵列，这意味着必须使用双引号（“）周围的话不单引号（'）。</p></blockquote> <p>与 <em>shell</em> 表单 不同 ， <em>exec</em> 表单不会调用命令shell。 这意味着不会发生常规的外壳处理。 例如， <code>CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</code> 将不会对进行变量替换 <code>$HOME</code> 。 如果要进行shell处理，则可以使用 <em>shell</em> 形式或直接执行shell，例如： <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code> 。 当使用exec表单并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。</p> <p>当以shell或exec格式使用时，该 <code>CMD</code> 指令设置运行映像时要执行的命令。</p> <p>如果您使用的 <em>外壳</em> 形式 <code>CMD</code> ，则将在中 <code>&lt;command&gt;</code> 执行 <code>/bin/sh -c</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
CMD echo &quot;This is a test.&quot; | wc -

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果要 <strong>在</strong> <code>&lt;command&gt;</code> <strong>没有外壳</strong> <strong>的<strong><strong>情况下</strong></strong>运行，</strong> 则必须将命令表示为JSON数组，并提供可执行文件的完整路径。 <strong>此数组形式是的首选格式<code>CMD</code>。</strong> 任何其他参数必须在数组中分别表示为字符串：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果您希望容器每次都运行相同的可执行文件，则应考虑 <code>ENTRYPOINT</code> 与结合使用 <code>CMD</code> 。 请参阅 <a href="#entrypoint"><em>ENTRYPOINT</em></a> 。</p> <p>如果用户指定的参数， <code>docker run</code> 则它们将覆盖中指定的默认参数 <code>CMD</code> 。</p> <blockquote><p><strong>注意</strong></p> <p>不要 <code>RUN</code> 与 混淆 <code>CMD</code> 。 <code>RUN</code> 实际上运行命令并提交结果； <code>CMD</code> 在生成时不执行任何操作，但是指定映像的预期命令。</p></blockquote> <h2 id="标签-🔗">标签 <a href="#label">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>LABEL</code> 指令将元数据添加到图像。 A <code>LABEL</code> 是键值对。 要在 <code>LABEL</code> 值中 包含空格 ，请像在命令行分析中一样使用引号和反斜杠。 一些用法示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;
LABEL com.example.label-with-value=&quot;foo&quot;
LABEL version=&quot;1.0&quot;
LABEL description=&quot;This text illustrates \
that label-values can span multiple lines.&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>一幅图像可以有多个标签。 您可以在一行上指定多个标签。 在Docker 1.10之前的版本中，这减小了最终映像的大小，但是情况不再如此。 您仍然可以通过以下两种方式之一选择在一条指令中指定多个标签：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>LABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>LABEL multi.label1=&quot;value1&quot; \
      multi.label2=&quot;value2&quot; \
      other=&quot;value3&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>基本或父图像（该 <code>FROM</code> 行中的图像）中 包含的标签 由您的图像继承。 如果标签已经存在但具有不同的值，则最近应用的值将覆盖任何先前设置的值。</p> <p>要查看图像的标签，请使用 <code>docker image inspect</code> 命令。 您可以使用该 <code>--format</code> 选项仅显示标签。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker image inspect --format='' myimage

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>{
  &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;,
  &quot;com.example.label-with-value&quot;: &quot;foo&quot;,
  &quot;version&quot;: &quot;1.0&quot;,
  &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,
  &quot;multi.label1&quot;: &quot;value1&quot;,
  &quot;multi.label2&quot;: &quot;value2&quot;,
  &quot;other&quot;: &quot;value3&quot;
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="维护者-（已弃用）-🔗"><a href="#maintainer-deprecated">维护者</a> （已弃用） <a href="#maintainer-deprecated">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>MAINTAINER &lt;name&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>MAINTAINER</code> 指令设置 生成图像 的 <em>作者</em> 字段。 该 <code>LABEL</code> 指令是此版本的灵活得多，您应该改用它，因为它可以设置所需的任何元数据，并且可以轻松查看，例如使用 <code>docker inspect</code> 。 要设置与该 <code>MAINTAINER</code> 字段 对应的标签， 可以使用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>LABEL maintainer=&quot;SvenDowideit@home.org.au&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样 <code>docker inspect</code> ，其他标签 就可以显示出来 了。</p> <h2 id="暴露-🔗">暴露 <a href="#expose">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>EXPOSE</code> 指令通知Docker容器在运行时监听指定的网络端口。 您可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认值为TCP。</p> <p>该 <code>EXPOSE</code> 指令实际上并未发布端口。 它充当构建映像的人员和运行容器的人员之间的一种文档类型，有关打算发布哪些端口的信息。 要在运行容器时实际发布端口，请使用 <code>-p</code> 标记on <code>docker run</code> 发布和映射一个或多个端口，或者使用 <code>-P</code> 标记发布所有公开的端口并将它们映射到高阶端口。</p> <p>默认情况下， <code>EXPOSE</code> 假定为TCP。 您还可以指定UDP：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>EXPOSE 80/udp

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要同时在TCP和UDP上公开，请包括以下两行：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>EXPOSE 80/tcp
EXPOSE 80/udp

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这种情况下，如果 <code>-P</code> 与配合 使用 <code>docker run</code> ，则该端口仅对TCP公开一次，对于UDP公开一次。 请记住， <code>-P</code> 该端口在主机上使用临时的高阶主机端口，因此该端口对于TCP和UDP将是不同的。</p> <p>无论 <code>EXPOSE</code> 设置 如何 ，都可以在运行时使用该 <code>-p</code> 标志 覆盖它们 。 例如</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -p 80:80/tcp -p 80:80/udp ...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要在主机系统上设置端口重定向，请参阅 <a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports" target="_blank" rel="noopener noreferrer">使用-P标志<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。 该 <code>docker network</code> 命令支持创建网络以在容器之间进行通信，而无需暴露或发布特定端口，因为连接到网络的容器可以通过任何端口相互通信。 有关详细信息，请参阅 <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener noreferrer">此功能<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener noreferrer">概述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <h2 id="环保-v">环保 <a href="#env">V</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key&gt;=&lt;value&gt; ...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>该 <code>ENV</code> 指令将环境变量 <code>&lt;key&gt;</code> 设置为value <code>&lt;value&gt;</code> 。 此值将在构建阶段中所有后续指令的环境中使用，并且可以 在很多情况下 <a href="#environment-replacement">内联替换</a> 。</p> <p>该 <code>ENV</code> 指令有两种形式。 第一种形式， <code>ENV &lt;key&gt; &lt;value&gt;</code> 会将一个变量设置为一个值。 第一个空格之后的整个字符串将被视为 <code>&lt;value&gt;</code> -包括空格字符。 该值将为其他环境变量解释，因此如果不对引号字符进行转义，则将其删除。</p> <p>第二种形式 <code>ENV &lt;key&gt;=&lt;value&gt; ...</code> 允许一次设置多个变量。 请注意，第二种形式在语法中使用等号（=），而第一种形式则不使用等号（=）。 与命令行分析一样，引号和反斜杠可用于在值中包含空格。</p> <p>例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \
    myCat=fluffy

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>和</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV myName John Doe
ENV myDog Rex The Dog
ENV myCat fluffy

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>将在最终图像中产生相同的净结果。</p> <p><code>ENV</code> 从结果映像运行容器时， 使用设置的环境变量 将保留。 您可以使用查看值 <code>docker inspect</code> ，并使用更改它们 <code>docker run --env &lt;key&gt;=&lt;value&gt;</code> 。</p> <blockquote><p><strong>注意</strong></p> <p>环境持久性可能导致意外的副作用。 例如，设置 <code>ENV DEBIAN_FRONTEND noninteractive</code> 可能会使基于Debian的映像上的apt-get用户感到困惑。 要为单个命令设置值，请使用 <code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code> 。</p></blockquote> <h2 id="添加-🔗">添加 <a href="#add">🔗</a></h2> <p>ADD有两种形式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>包含空格的路径需要后一种形式。</p> <blockquote><p><strong>注意</strong></p> <p>该 <code>--chown</code> 功能仅在用于构建Linux容器的Dockerfiles上受支持，而在Windows容器上不起作用。 由于用户和组所有权概念不会在Linux和Windows之间转换，因此使用 <code>/etc/passwd</code> 和 <code>/etc/group</code> 将用户名和组名转换为ID的使用限制了此功能仅适用于基于Linux OS的容器。</p></blockquote> <p>该 <code>ADD</code> 指令从中复制新文件，目录或远程文件URL <code>&lt;src&gt;</code> ，并将它们添加到路径中映像的文件系统中 <code>&lt;dest&gt;</code> 。</p> <p><code>&lt;src&gt;</code> 可以指定 多个 资源，但是如果它们是文件或目录，则将其路径解释为相对于构建上下文源的路径。</p> <p>每个都 <code>&lt;src&gt;</code> 可能包含通配符，并且匹配将使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener noreferrer">filepath.Match<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 规则完成。 例如：</p> <p>要添加所有以“ hom”开头的文件：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD hom* /mydir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在下面的示例中， <code>?</code> 被替换为任何单个字符，例如“ home.txt”。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD hom?.txt /mydir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>的 <code>&lt;dest&gt;</code> 是一个绝对路径，或相对于一个路径 <code>WORKDIR</code> ，到其中的源将在目标容器内进行复制。</p> <p>下面的示例使用相对路径，并将“ test.txt”添加到 <code>&lt;WORKDIR&gt;/relativeDir/</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD test.txt relativeDir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而此示例使用绝对路径，并向其中添加“ test.txt” <code>/absoluteDir/</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD test.txt /absoluteDir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>添加包含特殊字符（例如 <code>[</code> 和 <code>]</code> ）的 文件或目录时 ，您需要按照Golang规则转义那些路径，以防止将它们视为匹配模式。 例如，要添加名为的文件 <code>arr[0].txt</code> ，请使用以下命令；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD arr[[]0].txt /mydir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>除非可选 <code>--chown</code> 标志指定给定的用户名，组名或UID / GID组合以请求对所添加内容的特定所有权 ，否则所有新文件和目录的UID和GID均为0 。 <code>--chown</code> 标志 的格式 允许用户名和组名字符串或直接整数UID和GID任意组合。 提供不带组名的用户名或不带GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则将使用容器的根文件系统 <code>/etc/passwd</code> 和 <code>/etc/group</code> 文件将名称分别转换为整数UID或GID。 以下示例显示了该 <code>--chown</code> 标志的 有效定义 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果容器根文件系统不包含 <code>/etc/passwd</code> 或 <code>/etc/group</code> 文件，并且在 <code>--chown</code> 标志 中使用了用户名或组名 ，则该构建将在该 <code>ADD</code> 操作 上失败 。 使用数字ID不需要查找，并且不依赖于容器根文件系统内容。</p> <p>如果 <code>&lt;src&gt;</code> 是远程文件URL，则目标将具有600的权限。如果要检索的远程文件具有HTTP <code>Last-Modified</code> 标头，则该标头中的时间戳将用于设置 <code>mtime</code> 目标文件上的 时间戳 。 但是，就像在期间处理的任何其他文件一样 <code>ADD</code> ， <code>mtime</code> 该文件是否已更改以及是否应更新缓存的确定将不包括在内。</p> <blockquote><p><strong>注意</strong></p> <p>如果通过传递 <code>Dockerfile</code> STDIN（ <code>docker build - &lt; somefile</code> ）进行构建，则没有构建上下文，因此 <code>Dockerfile</code> 只能包含基于URL的 <code>ADD</code> 指令。 您还可以通过STDIN：（ <code>docker build - &lt; archive.tar.gz</code> ） 传递压缩的归档文件，归档文件 <code>Dockerfile</code> 根目录中的，归档文件的其余部分将用作构建的上下文。</p></blockquote> <p>如果您的网址文件都使用认证保护，则需要使用 <code>RUN wget</code> ， <code>RUN curl</code> 或作为从容器内使用另一种工具 <code>ADD</code> 指令不支持认证。</p> <blockquote><p><strong>注意</strong></p> <p><code>ADD</code> 如果Dockerfile的内容 <code>&lt;src&gt;</code> 已更改 ，则第一个遇到的 指令将使Dockerfile中所有后续指令的缓存无效 。 这包括使高速缓存中的 <code>RUN</code> 指令 无效 。 有关 更多信息， 请参见 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" target="_blank" rel="noopener noreferrer"><code>Dockerfile</code>最佳实践指南–利用构建缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p></blockquote> <p><code>ADD</code> 遵守以下规则：</p> <ul><li><p>该 <code>&lt;src&gt;</code> 路径必须是内部 <em>语境</em> 的构建; 您不能这样做 <code>ADD ../something /something</code> ，因为a的第一步 <code>docker build</code> 是将上下文目录（和子目录）发送到docker守护程序。</p></li> <li><p>如果 <code>&lt;src&gt;</code> 是URL， <code>&lt;dest&gt;</code> 并且不以斜杠结尾，则从URL下载文件并将其复制到 <code>&lt;dest&gt;</code> 。</p></li> <li><p>如果 <code>&lt;src&gt;</code> 是URL并 <code>&lt;dest&gt;</code> 以斜杠结尾，则从URL推断文件名，然后将文件下载到 <code>&lt;dest&gt;/&lt;filename&gt;</code> 。 例如， <code>ADD http://example.com/foobar /</code> 将创建文件 <code>/foobar</code> 。 该URL必须具有非平凡的路径，以便在这种情况下可以发现适当的文件名（ <code>http://example.com</code> 将不起作用）。</p></li> <li><p>如果 <code>&lt;src&gt;</code> 是目录，则将复制目录的整个内容，包括文件系统元数据。</p></li></ul> <blockquote><p><strong>注意</strong></p> <p>该目录本身不被复制，仅被复制其内容。</p></blockquote> <ul><li><p>如果 <code>&lt;src&gt;</code> 是以 公认的压缩格式（身份，gzip，bzip2或xz）作为 <em>本地</em> tar归档文件，则将其解压缩为目录。 来自 <em>远程</em> URL的 资源 <strong>不会被</strong> 解压缩。 复制或解压缩目录时，其行为与相同 <code>tar -x</code> ，结果是以下各项的并集：</p> <ol><li>目标路径上存在的任何内容</li> <li>源代码树的内容，已解决冲突，而选择了“ 2”。 在逐个文件的基础上。</li></ol> <blockquote><p><strong>注意</strong></p> <p>是否仅将文件内容而不是文件名确定为文件是公认的压缩格式。 例如，如果一个空文件恰好以 <code>.tar.gz</code> 该 文件结尾， 则不会被识别为压缩文件，并且 <strong>不会</strong> 生成任何类型的解压缩错误消息，而是会将文件简单地复制到目标位置。</p></blockquote></li> <li><p>如果 <code>&lt;src&gt;</code> 是任何其他类型的文件，则将其及其元数据一起单独复制。 在这种情况下，如果 <code>&lt;dest&gt;</code> 以斜杠结尾 <code>/</code> ，它将被视为目录，其内容 <code>&lt;src&gt;</code> 将写入 <code>&lt;dest&gt;/base(&lt;src&gt;)</code> 。</p></li> <li><p>如果 <code>&lt;src&gt;</code> 直接或由于使用通配符而指定了 多个 资源，则该资源 <code>&lt;dest&gt;</code> 必须是目录，并且必须以斜杠结尾 <code>/</code> 。</p></li> <li><p>如果 <code>&lt;dest&gt;</code> 不以斜杠结尾，则将其视为常规文件，并将其内容 <code>&lt;src&gt;</code> 写入 <code>&lt;dest&gt;</code> 。</p></li> <li><p>如果 <code>&lt;dest&gt;</code> 不存在，它将与路径中所有缺少的目录一起创建。</p></li></ul> <h2 id="复制-🔗">复制 <a href="#copy">🔗</a></h2> <p>COPY有两种形式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>包含空格的路径需要后一种形式</p> <blockquote><p><strong>注意</strong></p> <p>该 <code>--chown</code> 功能仅在用于构建Linux容器的Dockerfiles上受支持，而在Windows容器上不起作用。 由于用户和组所有权概念不会在Linux和Windows之间转换，因此使用 <code>/etc/passwd</code> 和 <code>/etc/group</code> 将用户名和组名转换为ID的使用限制了此功能仅适用于基于Linux OS的容器。</p></blockquote> <p>该 <code>COPY</code> 指令从中复制新文件或目录 <code>&lt;src&gt;</code> ，并将它们添加到路径中容器的文件系统中 <code>&lt;dest&gt;</code> 。</p> <p><code>&lt;src&gt;</code> 可以指定 多个 资源，但是文件和目录的路径将被解释为相对于构建上下文的源。</p> <p>每个都 <code>&lt;src&gt;</code> 可能包含通配符，并且匹配将使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener noreferrer">filepath.Match<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 规则完成。 例如：</p> <p>要添加所有以“ hom”开头的文件：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY hom* /mydir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在下面的示例中， <code>?</code> 被替换为任何单个字符，例如“ home.txt”。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY hom?.txt /mydir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>的 <code>&lt;dest&gt;</code> 是一个绝对路径，或相对于一个路径 <code>WORKDIR</code> ，到其中的源将在目标容器内进行复制。</p> <p>下面的示例使用相对路径，并将“ test.txt”添加到 <code>&lt;WORKDIR&gt;/relativeDir/</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY test.txt relativeDir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而此示例使用绝对路径，并向其中添加“ test.txt” <code>/absoluteDir/</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY test.txt /absoluteDir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>复制包含特殊字符（例如 <code>[</code> 和 <code>]</code> ）的 文件或目录时 ，您需要按照Golang规则转义那些路径，以防止将它们视为匹配模式。 例如，要添加名为的文件 <code>arr[0].txt</code> ，请使用以下命令；</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD arr[[]0].txt /mydir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>除非可选 <code>--chown</code> 标志指定给定的用户名，组名或UID / GID组合以请求对复制内容的特定所有权 ，否则所有新文件和目录的UID和GID均为0 。 <code>--chown</code> 标志 的格式 允许用户名和组名字符串或直接整数UID和GID任意组合。 提供不带组名的用户名或不带GID的UID将使用与GID相同的数字UID。 如果提供了用户名或组名，则将使用容器的根文件系统 <code>/etc/passwd</code> 和 <code>/etc/group</code> 文件将名称分别转换为整数UID或GID。 以下示例显示了该 <code>--chown</code> 标志的 有效定义 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY --chown=55:mygroup files* /somedir/
COPY --chown=bin files* /somedir/
COPY --chown=1 files* /somedir/
COPY --chown=10:11 files* /somedir/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果容器根文件系统不包含 <code>/etc/passwd</code> 或 <code>/etc/group</code> 文件，并且在 <code>--chown</code> 标志 中使用了用户名或组名 ，则该构建将在该 <code>COPY</code> 操作 上失败 。 使用数字ID不需要查找，并且不依赖于容器根文件系统内容。</p> <blockquote><p><strong>注意</strong></p> <p>如果使用STDIN（ <code>docker build - &lt; somefile</code> ）进行 构建 ，则没有构建上下文，因此 <code>COPY</code> 无法使用。</p></blockquote> <p>（可选） <code>COPY</code> 接受一个标志 <code>--from=&lt;name|index&gt;</code> ， 该标志 可用于将源位置设置为 <code>FROM .. AS &lt;name&gt;</code> 将用于代替用户发送的构建上下文 的上一个构建阶段（使用创建 ）。 该标志还接受为以 <code>FROM</code> 指令 开头的所有先前构建阶段分配的数字索引 。 如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的映像代替。</p> <p><code>COPY</code> 遵守以下规则：</p> <ul><li><p>该 <code>&lt;src&gt;</code> 路径必须是内部 <em>语境</em> 的构建; 您不能这样做 <code>COPY ../something /something</code> ，因为a的第一步 <code>docker build</code> 是将上下文目录（和子目录）发送到docker守护程序。</p></li> <li><p>如果 <code>&lt;src&gt;</code> 是目录，则将复制目录的整个内容，包括文件系统元数据。</p></li></ul> <blockquote><p><strong>注意</strong></p> <p>该目录本身不被复制，仅被复制其内容。</p></blockquote> <ul><li><p>如果 <code>&lt;src&gt;</code> 是任何其他类型的文件，则将其及其元数据一起单独复制。 在这种情况下，如果 <code>&lt;dest&gt;</code> 以斜杠结尾 <code>/</code> ，它将被视为目录，其内容 <code>&lt;src&gt;</code> 将写入 <code>&lt;dest&gt;/base(&lt;src&gt;)</code> 。</p></li> <li><p>如果 <code>&lt;src&gt;</code> 直接或由于使用通配符而指定了 多个 资源，则该资源 <code>&lt;dest&gt;</code> 必须是目录，并且必须以斜杠结尾 <code>/</code> 。</p></li> <li><p>如果 <code>&lt;dest&gt;</code> 不以斜杠结尾，则将其视为常规文件，并将其内容 <code>&lt;src&gt;</code> 写入 <code>&lt;dest&gt;</code> 。</p></li> <li><p>如果 <code>&lt;dest&gt;</code> 不存在，它将与路径中所有缺少的目录一起创建。</p></li></ul> <blockquote><p><strong>注意</strong></p> <p><code>COPY</code> 如果Dockerfile的内容 <code>&lt;src&gt;</code> 已更改 ，则第一个遇到的 指令将使Dockerfile中所有后续指令的缓存无效 。 这包括使高速缓存中的 <code>RUN</code> 指令 无效 。 有关 更多信息， 请参见 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" target="_blank" rel="noopener noreferrer"><code>Dockerfile</code>最佳实践指南–利用构建缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p></blockquote> <h2 id="入口点-🔗">入口点 <a href="#entrypoint">🔗</a></h2> <p>ENTRYPOINT有两种形式：</p> <p>在 <em>EXEC</em> 的形式，这是优选的形式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <em>壳</em> 形式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENTRYPOINT command param1 param2

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>An <code>ENTRYPOINT</code> 允许您配置将作为可执行文件运行的容器。</p> <p>例如，以下代码以其默认内容启动nginx，监听端口80：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker run -i -t --rm -p 80:80 nginx

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>命令行参数to <code>docker run &lt;image&gt;</code> 将以 <em>exec</em> 形式 附加在所有元素之后 <code>ENTRYPOINT</code> ，并将覆盖使用指定的所有元素 <code>CMD</code> 。 这允许将参数传递给入口点，即， <code>docker run &lt;image&gt; -d</code> 将 <code>-d</code> 参数 传递 给入口点。 您可以 <code>ENTRYPOINT</code> 使用该 <code>docker run --entrypoint</code> 标志 覆盖 指令 。</p> <p>所述 <em>壳</em> 形式防止任何 <code>CMD</code> 或 <code>run</code> 被使用命令行参数，但具有的缺点是你 <code>ENTRYPOINT</code> 将开始作为的子命令 <code>/bin/sh -c</code> ，其不通过信号。 这意味着可执行文件将不是容器的 <code>PID 1</code> -并且将 <em>不会</em> 接收Unix信号-因此您的可执行文件将不会 <code>SIGTERM</code> 从 接收 到 <code>docker stop &lt;container&gt;</code> 。</p> <p>只有中的最后一条 <code>ENTRYPOINT</code> 指令 <code>Dockerfile</code> 才会生效。</p> <h3 id="执行表格entrypoint示例-🔗">执行表格ENTRYPOINT示例 <a href="#exec-form-entrypoint-example">🔗</a></h3> <p>您可以使用 <em>exec</em> 形式的 <code>ENTRYPOINT</code> 来设置相当稳定的默认命令和参数，然后使用这两种形式的 <code>CMD</code> 来设置更可能被更改的其他默认值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]
CMD [&quot;-c&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>运行容器时，可以看到这 <code>top</code> 是唯一的过程：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker run -it --rm --name test  top -H

top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05
Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers
KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>要进一步检查结果，可以使用 <code>docker exec</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker exec -it test ps aux

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H
root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>您也可以使用优雅地请求 <code>top</code> 关闭 <code>docker stop test</code> 。</p> <p>下面 <code>Dockerfile</code> 显示了使用 <code>ENTRYPOINT</code> 来在前台运行Apache（即as <code>PID 1</code> ）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM debian:stable
RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2
EXPOSE 80 443
VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]
ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果需要为单个可执行文件编写启动脚本，则可以使用 <code>exec</code> 和 <code>gosu</code> 命令 确保最终的可执行文件接收Unix信号 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#!/usr/bin/env bash
set -e

if [ &quot;$1&quot; = 'postgres' ]; then
    chown -R postgres &quot;$PGDATA&quot;

    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then
        gosu postgres initdb
    fi

    exec gosu postgres &quot;$@&quot;
fi

exec &quot;$@&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>最后，如果您需要在关闭时进行一些额外的清理（或与其他容器通信），或者协调多个可执行文件，则可能需要确保 <code>ENTRYPOINT</code> 脚本接收Unix信号，将其传递，然后执行一些更多的工作：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#!/bin/sh
# Note: I've written this using sh so it works in the busybox container too

# USE the trap if you need to also do manual cleanup after the service is stopped,
#     or need to start multiple services in the one container
trap &quot;echo TRAPed signal&quot; HUP INT QUIT TERM

# start service in background here
/usr/sbin/apachectl start

echo &quot;[hit enter key to exit] or run 'docker stop &lt;container&gt;'&quot;
read

# stop service and clean up here
echo &quot;stopping apache&quot;
/usr/sbin/apachectl stop

echo &quot;exited $0&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>如果使用运行该映像 <code>docker run -it --rm -p 80:80 --name test apache</code> ，则可以使用 <code>docker exec</code> 或 来检查容器的进程 <code>docker top</code> ，然后要求脚本停止Apache：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker exec -it test ps aux

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 /bin/sh /run.sh 123 cmd cmd2
root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 /usr/sbin/apache2 -k start
www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start
www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start
root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux

$ docker top test

PID                 USER                COMMAND
10035               root                {run.sh} /bin/sh /run.sh 123 cmd cmd2
10054               root                /usr/sbin/apache2 -k start
10055               33                  /usr/sbin/apache2 -k start
10056               33                  /usr/sbin/apache2 -k start

$ /usr/bin/time docker stop test

test
real	0m 0.27s
user	0m 0.03s
sys	0m 0.03s

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p><strong>注意</strong></p> <p>您可以使用覆盖 <code>ENTRYPOINT</code> 设置 <code>--entrypoint</code> ，但这只能将二进制文件设置为 <em>exec</em> （ <code>sh -c</code> 将不使用）。</p></blockquote> <blockquote><p><strong>注意</strong></p> <p>在 <em>EXEC</em> 形式被解析为一个JSON阵列，这意味着必须使用双引号（“）周围的话不单引号（'）。</p></blockquote> <p>与 <em>shell</em> 表单 不同 ， <em>exec</em> 表单不会调用命令shell。 这意味着不会发生常规的外壳处理。 例如， <code>ENTRYPOINT [ &quot;echo&quot;, &quot;$HOME&quot; ]</code> 将不会对进行变量替换 <code>$HOME</code> 。 如果要进行shell处理，则可以使用 <em>shell</em> 形式或直接执行shell，例如： <code>ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code> 。 当使用exec表单并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。</p> <h3 id="外壳形式entrypoint示例-example">外壳形式ENTRYPOINT示例 <a href="#shell-form-entrypoint-example">example</a></h3> <p>您可以为指定一个纯字符串 <code>ENTRYPOINT</code> ，它将在中执行 <code>/bin/sh -c</code> 。 这种形式将使用外壳处理来替代外壳环境变量，并且将忽略任何 <code>CMD</code> 或 <code>docker run</code> 命令行参数。 为了确保能够 正确 <code>docker stop</code> 发出任何长期运行的 <code>ENTRYPOINT</code> 可执行文件 信号 ，您需要记住以以下命令启动它 <code>exec</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ENTRYPOINT exec top -b

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>运行此图像时，您将看到单个 <code>PID 1</code> 过程：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker run -it --rm --name test top

Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached
CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq
Load average: 0.08 0.03 0.05 2/98 6
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
    1     0 root     R     3164   0%   0% top -b

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>干净地退出 <code>docker stop</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ /usr/bin/time docker stop test

test
real	0m 0.20s
user	0m 0.02s
sys	0m 0.04s

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果您忘记添加 <code>exec</code> 到您的开头 <code>ENTRYPOINT</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ENTRYPOINT top -b
CMD --ignored-param1

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后，您可以运行它（为下一步命名）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker run -it --name test top --ignored-param2

Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached
CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq
Load average: 0.01 0.02 0.05 2/101 7
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
    1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2
    7     1 root     R     3164   0%   0% top -b

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>从输出中可以看到 <code>top</code> ，指定 <code>ENTRYPOINT</code> 的不是 <code>PID 1</code> 。</p> <p>如果随后运行 <code>docker stop test</code> ，容器将不会干净退出- 超时后将 <code>stop</code> 强制命令发送a <code>SIGKILL</code> ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker exec -it test ps aux

PID   USER     COMMAND
    1 root     /bin/sh -c top -b cmd cmd2
    7 root     top -b
    8 root     ps aux

$ /usr/bin/time docker stop test

test
real	0m 10.19s
user	0m 0.04s
sys	0m 0.03s

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="了解cmd和entrypoint如何相互作用-🔗">了解CMD和ENTRYPOINT如何相互作用 <a href="#understand-how-cmd-and-entrypoint-interact">🔗</a></h3> <p>无论 <code>CMD</code> 和 <code>ENTRYPOINT</code> 指令定义运行的容器中时什么命令得到执行。 很少有规则描述他们的合作。</p> <ol><li><p>Dockerfile应该指定 <code>CMD</code> 或 <code>ENTRYPOINT</code> 命令 中的至少一个 。</p></li> <li><p><code>ENTRYPOINT</code> 使用容器作为可执行文件时应定义。</p></li> <li><p><code>CMD</code> 应该用作定义 <code>ENTRYPOINT</code> 命令 默认值 或在容器中执行临时命令的方式。</p></li> <li><p><code>CMD</code> 当使用其他参数运行容器时，将被覆盖。</p></li></ol> <p>下表显示了针对不同 <code>ENTRYPOINT</code> / <code>CMD</code> 组合 执行的命令 ：</p> <table><thead><tr><th></th> <th>没有入口点</th> <th>ENTRYPOINT exec_entry p1_entry</th> <th>ENTRYPOINT [“ exec_entry”，“ p1_entry”]</th></tr></thead> <tbody><tr><td><strong>没有CMD</strong></td> <td><em>错误，不允许</em></td> <td>/ bin / sh -c exec_entry p1_entry</td> <td>exec_entry p1_entry</td></tr> <tr><td><strong>CMD [“ exec_cmd”，“ p1_cmd”]</strong></td> <td>exec_cmd p1_cmd</td> <td>/ bin / sh -c exec_entry p1_entry</td> <td>exec_entry p1_entry exec_cmd p1_cmd</td></tr> <tr><td><strong>CMD [“ p1_cmd”，“ p2_cmd”]</strong></td> <td>p1_cmd p2_cmd</td> <td>/ bin / sh -c exec_entry p1_entry</td> <td>exec_entry p1_entry p1_cmd p2_cmd</td></tr> <tr><td><strong>CMD exec_cmd p1_cmd</strong></td> <td>/ bin / sh -c exec_cmd p1_cmd</td> <td>/ bin / sh -c exec_entry p1_entry</td> <td>exec_entry p1_entry / bin / sh -c exec_cmd p1_cmd</td></tr></tbody></table> <blockquote><p><strong>注意</strong></p> <p>如果 <code>CMD</code> 从基本图像定义，则设置 <code>ENTRYPOINT</code> 将重置 <code>CMD</code> 为空值。 在这种情况下， <code>CMD</code> 必须在当前图像中定义一个值。</p></blockquote> <h2 id="音量-🔗">音量 <a href="#volume">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>VOLUME [&quot;/data&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>VOLUME</code> 指令创建具有指定名称的安装点，并将其标记为保存来自本机主机或其他容器的外部安装的卷。 该值可以是JSON数组，也可以是 <code>VOLUME [&quot;/var/log/&quot;]</code> 具有多个参数的纯字符串，例如 <code>VOLUME /var/log</code> 或 <code>VOLUME /var/log /var/db</code> 。 有关通过Docker客户端的更多信息/示例和安装说明，请参阅 <a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener noreferrer"><em>通过Volumes共享目录</em><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <p>该 <code>docker run</code> 命令使用基本映像内指定位置上存在的任何数据初始化新创建的卷。 例如，考虑以下Dockerfile片段：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
RUN mkdir /myvol
RUN echo &quot;hello world&quot; &gt; /myvol/greeting
VOLUME /myvol

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>该Dockerfile生成一个映像，该映像导致 <code>docker run</code> 在处创建一个新的挂载点 <code>/myvol</code> 并将该 <code>greeting</code> 文件 复制 到新创建的卷中。</p> <h3 id="有关指定卷的注意事项-🔗">有关指定卷的注意事项 <a href="#notes-about-specifying-volumes">🔗</a></h3> <p>关于。中的卷，请注意以下几点 <code>Dockerfile</code> 。</p> <ul><li><p><strong>基于Windows的容器上的卷</strong> ：使用基于Windows的容器时，容器内的卷的目的地必须是以下之一：</p> <ul><li>不存在或空目录</li> <li>除以下以外的驱动器 <code>C:</code></li></ul></li> <li><p><strong>从Dockerfile中更改卷</strong> ：如果在声明了卷之后有任何构建步骤更改了卷中的数据，则这些更改将被丢弃。</p></li> <li><p><strong>JSON格式</strong> ：列表被解析为JSON数组。 您必须用双引号（ <code>&quot;</code> ）而不是单引号（ <code>'</code> ） 括住单词 。</p></li> <li><p><strong>主机目录是在容器运行时声明的</strong> ：主机目录（挂载点）从本质上说是依赖于主机的。 这是为了保留图像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。 因此，您无法从Dockerfile中挂载主机目录。 该 <code>VOLUME</code> 指令不支持指定 <code>host-dir</code> 参数。 创建或运行容器时，必须指定安装点。</p></li></ul> <h2 id="用户-🔗">用户 <a href="#user">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>USER &lt;user&gt;[:&lt;group&gt;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>要么</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>USER &lt;UID&gt;[:&lt;GID&gt;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>USER</code> 指令设置运行映像时以及用于任何映像时使用的用户名（或UID）和可选的用户组（或GID） <code>RUN</code> ， <code>CMD</code> 以及在 <code>ENTRYPOINT</code> 后面跟随的指令 <code>Dockerfile</code> 。</p> <blockquote><p>请注意，在为用户指定组时，用户将 <em>仅</em> 具有指定的组成员身份。 任何其他已配置的组成员身份将被忽略。</p></blockquote> <blockquote><p><strong>警告</strong></p> <p>当用户没有主要组时，该映像（或后续说明）将与该 <code>root</code> 组 一起运行 。</p> <p>在Windows上，如果不是内置帐户，则必须首先创建用户。 这可以通过 <code>net user</code> 作为Dockerfile的一部分调用 的 命令 来完成 。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM microsoft/windowsservercore
# Create Windows user in the container
RUN net user /add patrick
# Set it for subsequent commands
USER patrick

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="workdir-🔗">WORKDIR <a href="#workdir">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>WORKDIR /path/to/workdir

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>WORKDIR</code> 指令集的工作目录对任何 <code>RUN</code> ， <code>CMD</code> ， <code>ENTRYPOINT</code> ， <code>COPY</code> 和 <code>ADD</code> 它后面的说明 <code>Dockerfile</code> 。 如果 <code>WORKDIR</code> 不存在，即使以后的任何 <code>Dockerfile</code> 指令 中都没有使用它，也将创建它 。</p> <p>该 <code>WORKDIR</code> 指令可以在中多次使用 <code>Dockerfile</code> 。 如果提供了相对路径，则它将相对于上一条 <code>WORKDIR</code> 指令 的路径 。 例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最终的输出 <code>pwd</code> 命令这 <code>Dockerfile</code> 将是 <code>/a/b/c</code> 。</p> <p>该 <code>WORKDIR</code> 指令可以解析先前使用设置的环境变量 <code>ENV</code> 。 您只能使用在中显式设置的环境变量 <code>Dockerfile</code> 。 例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>最终 <code>pwd</code> 命令 的输出 <code>Dockerfile</code> 将是 <code>/path/$DIRNAME</code></p> <h2 id="arg-🔗">ARG <a href="#arg">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>ARG &lt;name&gt;[=&lt;default value&gt;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>ARG</code> 指令定义了一个变量，用户可以在构建时 <code>docker build</code> 使用 带有 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志 的 命令将其 传递给构建器 。 如果用户指定了Dockerfile中未定义的构建参数，则该构建会输出警告。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[Warning] One or more build-args [foo] were not consumed.

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Dockerfile可能包含一个或多个 <code>ARG</code> 指令。 例如，以下是有效的Dockerfile：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM busybox
ARG user1
ARG buildno
# ...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p><strong>警告：</strong></p> <p>不建议使用构建时变量来传递诸如github密钥，用户凭据等机密。构建时变量值对于使用该 <code>docker history</code> 命令 的图像的任何用户都是可见的 。</p> <p>请参阅 <a href="https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information" target="_blank" rel="noopener noreferrer">“使用BuildKit生成映像”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 部分，以了解有关在生成映像时使用机密的安全方法。</p></blockquote> <h3 id="默认值-🔗">默认值 <a href="#default-values">🔗</a></h3> <p>的 <code>ARG</code> 指令可以可选地包括一个默认值：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM busybox
ARG user1=someuser
ARG buildno=1
# ...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果 <code>ARG</code> 指令具有缺省值，并且在构建时未传递任何值，那么构建器将使用缺省值。</p> <h3 id="范围-🔗">范围 <a href="#scope">🔗</a></h3> <p>一个 <code>ARG</code> 变量定义进入从在其上在限定的线效果 <code>Dockerfile</code> 不从参数对命令行或其他地方使用。 例如，考虑以下Dockerfile：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM busybox
USER ${user:-some_user}
ARG user
USER $user
# ...

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>用户通过调用以下命令来构建此文件：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build --build-arg user=what_user .

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>USER</code> 在第2行 ， at <code>some_user</code> 在 <code>user</code> 变量3上定义为。 <code>USER</code> 在第4 行， at 定义 为 <code>what_user</code> as <code>user</code> ，并且 <code>what_user</code> 在命令行上传递 了 值。 在通过 <code>ARG</code> 指令 对其进行定义之前 ，对变量的任何使用都会导致一个空字符串。</p> <p>的 <code>ARG</code> 指令在它被定义的构建阶段结束推移的范围进行。 要在多个阶段使用arg，每个阶段都必须包含 <code>ARG</code> 指令。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM busybox
ARG SETTINGS
RUN ./run/setup $SETTINGS

FROM busybox
ARG SETTINGS
RUN ./run/other $SETTINGS

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="使用arg变量-🔗">使用ARG变量 <a href="#using-arg-variables">🔗</a></h3> <p>您可以使用 <code>ARG</code> 或 <code>ENV</code> 指令指定该 <code>RUN</code> 指令 可用的变量 。 使用 <code>ENV</code> 指令 定义的环境变量 始终会覆盖 <code>ARG</code> 同名指令。 考虑此Dockerfile和 <code>ENV</code> and <code>ARG</code> 指令。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER v1.0.0
RUN echo $CONT_IMG_VER

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>然后，假定此映像是使用以下命令构建的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build --build-arg CONT_IMG_VER=v2.0.1 .

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这种情况下，该 <code>RUN</code> 指令将使用 <code>v1.0.0</code> 而不是 <code>ARG</code> 用户传递 的 设置： <code>v2.0.1</code> 此行为类似于Shell脚本，其中局部作用域的变量从其定义的角度覆盖作为参数传递或从环境继承的变量。</p> <p>使用上面的示例，但使用不同的 <code>ENV</code> 规范，可以在 <code>ARG</code> 和 <code>ENV</code> 指令 之间创建更有用的交互 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER ${CONT_IMG_VER:-v1.0.0}
RUN echo $CONT_IMG_VER

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>与 <code>ARG</code> 指令 不同 ， <code>ENV</code> 值始终保留在生成的映像中。 考虑不带 <code>--build-arg</code> 标志 的Docker构建 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ docker build .

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用此Dockerfile示例， <code>CONT_IMG_VER</code> 它仍然保留在映像中，但其值将是 指令 <code>v1.0.0</code> 第3行中的默认设置 <code>ENV</code> 。</p> <p>在此示例中，变量扩展技术使您可以从命令行传递参数，并利用 <code>ENV</code> 指令 将其保留在最终映像中 。 仅 <a href="#environment-replacement">有限的一组Dockerfile指令</a> 支持变量扩展 <a href="#environment-replacement">。</a></p> <h3 id="预定义的-args🔗">预定义的 <a href="#predefined-args">ARGs🔗</a></h3> <p>Docker具有一组预定义 <code>ARG</code> 变量，您可以在不使用 <code>ARG</code> Dockerfile中 相应 指令的情况下使用它们。</p> <ul><li><code>HTTP_PROXY</code></li> <li><code>http_proxy</code></li> <li><code>HTTPS_PROXY</code></li> <li><code>https_proxy</code></li> <li><code>FTP_PROXY</code></li> <li><code>ftp_proxy</code></li> <li><code>NO_PROXY</code></li> <li><code>no_proxy</code></li></ul> <p>要使用这些，只需使用以下标志在命令行中传递它们：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>--build-arg &lt;varname&gt;=&lt;value&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>默认情况下，这些预定义变量从的输出中排除 <code>docker history</code> 。 排除它们可以减少意外泄露 <code>HTTP_PROXY</code> 变量 中的敏感身份验证信息的风险 。</p> <p>例如，考虑使用以下命令构建以下Dockerfile <code>--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
RUN echo &quot;Hello World&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这种情况下， <code>HTTP_PROXY</code> 变量 的值在 中不可用， <code>docker history</code> 也不被缓存。 如果要更改位置，并且代理服务器已更改为 <code>http://user:pass@proxy.sfo.example.com</code> ，则后续的构建不会导致高速缓存未命中。</p> <p>如果您需要覆盖此行为，则可以通过 <code>ARG</code> 在Dockerfile中添加如下语句来做到这一点：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG HTTP_PROXY
RUN echo &quot;Hello World&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>构建此Dockerfile时，将 <code>HTTP_PROXY</code> 保留在中 <code>docker history</code> ，并且更改其值会使构建缓存无效。</p> <h3 id="全球范围内的自动平台-args🔗">全球范围内的自动平台 <a href="#automatic-platform-args-in-the-global-scope">ARGs🔗</a></h3> <p>仅当使用 <a href="#buildkit">BuildKit</a> 后端 时，此功能才可用 。</p> <p>Docker <code>ARG</code> 在执行构建的节点的平台（构建平台）和结果映像的平台（目标平台）上用信息 预定义了一组 变量。 可以使用 <code>--platform</code> 标志on 来指定目标平台 <code>docker build</code> 。</p> <p>以下 <code>ARG</code> 变量是自动设置的：</p> <ul><li><code>TARGETPLATFORM</code> -构建结果的平台。 例如 <code>linux/amd64</code> ， <code>linux/arm/v7</code> ， <code>windows/amd64</code> 。</li> <li><code>TARGETOS</code> -TARGETPLATFORM的OS组件</li> <li><code>TARGETARCH</code> -TARGETPLATFORM的体系结构组件</li> <li><code>TARGETVARIANT</code> -TARGETPLATFORM的变体组件</li> <li><code>BUILDPLATFORM</code> -执行构建的节点的平台。</li> <li><code>BUILDOS</code> -BUILDPLATFORM的OS组件</li> <li><code>BUILDARCH</code> -BUILDPLATFORM的体系结构组件</li> <li><code>BUILDVARIANT</code> -BUILDPLATFORM的变体组件</li></ul> <p>这些参数在全局范围内定义，因此在构建阶段或您的 <code>RUN</code> 命令 中不会自动提供 。 为了在构建阶段公开这些参数之一，请重新定义它而没有价值。</p> <p>例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM alpine
ARG TARGETPLATFORM
RUN echo &quot;I'm building for $TARGETPLATFORM&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="对构建缓存的影响-🔗">对构建缓存的影响 <a href="#impact-on-build-caching">🔗</a></h3> <p><code>ARG</code> 变量不会像 <code>ENV</code> 变量 那样持久化到生成的映像 中。 但是， <code>ARG</code> 变量确实以类似的方式影响构建缓存。 如果Dockerfile定义了一个 <code>ARG</code> 其值不同于先前构建 的 变量，则首次使用时会发生“缓存未命中”，而不是其定义。 特别是， <code>RUN</code> 一条指令之后的 所有 指令 都 隐式地 <code>ARG</code> 使用该 <code>ARG</code> 变量（作为环境变量），因此可能导致高速缓存未命中。 <code>ARG</code> 除非。中有匹配的 <code>ARG</code> 语句， 否则 所有预定义 变量均免于缓存 <code>Dockerfile</code> 。</p> <p>例如，考虑以下两个Dockerfile：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG CONT_IMG_VER
RUN echo $CONT_IMG_VER

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG CONT_IMG_VER
RUN echo hello

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果 <code>--build-arg CONT_IMG_VER=&lt;value&gt;</code> 在命令行上 指定 ，则在两种情况下，第2行上的 指定 都不会导致高速缓存未命中。 第3行确实会导致缓存未命中。 <code>ARG CONT_IMG_VER</code> 导致RUN行被标识为与正在运行的 <code>CONT_IMG_VER=&lt;value&gt;</code> echo hello 相同 ，因此，如果进行了 <code>&lt;value&gt;</code> 更改， 则会 遇到缓存未命中的情况。</p> <p>考虑在同一命令行下的另一个示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER $CONT_IMG_VER
RUN echo $CONT_IMG_VER

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在此示例中，高速缓存未命中发生在第3行。之所以发生未命中，是因为该变量在 <code>ENV</code> 引用中 的值 引用了该 <code>ARG</code> 变量，并且该变量通过命令行进行了更改。 在此示例中，该 <code>ENV</code> 命令使图像包含该值。</p> <p>如果一条 <code>ENV</code> 指令覆盖 <code>ARG</code> 了同名指令，例如Dockerfile：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER hello
RUN echo $CONT_IMG_VER

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第3行不会导致缓存未命中，因为的值 <code>CONT_IMG_VER</code> 是一个常量（ <code>hello</code> ）。 结果， <code>RUN</code> （第4行） 使用的环境变量和值 在两次构建之间不会更改。</p> <h2 id="已建-🔗">已建 <a href="#onbuild">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>ONBUILD &lt;INSTRUCTION&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当该图像用作另一个构建的基础时， 该 <code>ONBUILD</code> 指令会在图像上添加要 在以后执行 的 <em>触发</em> 指令。 触发器将在下游构建的上下文中执行，就好像它已 <code>FROM</code> 在下游指令 之后立即插入 <code>Dockerfile</code> 。</p> <p>任何构建指令都可以注册为触发器。</p> <p>如果要构建的图像将用作构建其他图像的基础，例如应用程序构建环境或可以使用用户特定配置自定义的守护程序，则此功能很有用。</p> <p>例如，如果您的图像是可重用的Python应用程序构建器，则将需要在特定目录中添加应用程序源代码，并且 <em>此后</em> 可能需要调用构建脚本 。 你不能只是打电话 <code>ADD</code> 和 <code>RUN</code> 现在，因为你还没有访问应用程序的源代码，这将是为每个应用程序生成不同的。 您可以简单地为应用程序开发人员提供 <code>Dockerfile</code> 可复制粘贴到其应用程序中 的样板 ，但这效率低下，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。</p> <p>解决方案是用于 <code>ONBUILD</code> 注册预先的指令，以便在下一个构建阶段中稍后运行。</p> <p>运作方式如下：</p> <ol><li>当遇到 <code>ONBUILD</code> 指令时，构建器将触发器添加到正在构建的图像的元数据中。 该指令不会影响当前版本。</li> <li>在构建结束时，所有触发器的列表都存储在映像清单的key下 <code>OnBuild</code> 。 可以使用 <code>docker inspect</code> 命令 检查它们 。</li> <li>稍后，可以使用该 <code>FROM</code> 指令 将该图像用作新版本的基础 。 作为处理 <code>FROM</code> 指令的 一部分 ，下游构建器将查找 <code>ONBUILD</code> 触发器，并按照注册时的顺序执行它们。 如果任何触发器失败，则该 <code>FROM</code> 指令将中止，进而导致构建失败。 如果所有触发器都成功，则 <code>FROM</code> 指令完成，并且构建照常继续。</li> <li>执行完触发器后，将从最终图像中清除触发器。 换句话说，它们不是“孙子代”版本所继承的。</li></ol> <p>例如，您可以添加以下内容：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p><strong>警告</strong></p> <p>不允许 <code>ONBUILD</code> 使用 链接 说明 <code>ONBUILD ONBUILD</code> 。</p></blockquote> <blockquote><p><strong>警告</strong></p> <p>该 <code>ONBUILD</code> 指令可能不会触发 <code>FROM</code> 或 <code>MAINTAINER</code> 指令。</p></blockquote> <h2 id="停止-信号🔗">停止 <a href="#stopsignal">信号🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>STOPSIGNAL signal

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>STOPSIGNAL</code> 指令设置将被发送到容器退出的系统调用信号。 该信号可以是与内核syscall表中的位置匹配的有效无符号数字（例如9），也可以是格式为SIGNAME的信号名称（例如SIGKILL）。</p> <h2 id="健康-检查🔗">健康 <a href="#healthcheck">检查🔗</a></h2> <p>该 <code>HEALTHCHECK</code> 指令有两种形式：</p> <ul><li><code>HEALTHCHECK [OPTIONS] CMD command</code> （通过在容器内部运行命令来检查容器的运行状况）</li> <li><code>HEALTHCHECK NONE</code> （禁用从基本映像继承的任何运行状况检查）</li></ul> <p>该 <code>HEALTHCHECK</code> 指令告诉Docker如何测试容器以检查其是否仍在工作。 这样可以检测到诸如Web服务器陷入无限循环并且无法处理新连接的情况，即使服务器进程仍在运行。</p> <p>指定容器的 <em>运行状况检查后</em> ，除了其正常状态外 ，它还具有<em>运行</em> 状况。 此状态最初为 <code>starting</code> 。 只要运行状况检查通过，它将变为 <code>healthy</code> （以前处于任何状态）。 在一定数量的连续失败之后，它变为 <code>unhealthy</code> 。</p> <p>之前可能出现的选项 <code>CMD</code> 是：</p> <ul><li><code>--interval=DURATION</code> （默认值： <code>30s</code> ）</li> <li><code>--timeout=DURATION</code> （默认值： <code>30s</code> ）</li> <li><code>--start-period=DURATION</code> （默认值： <code>0s</code> ）</li> <li><code>--retries=N</code> （默认值： <code>3</code> ）</li></ul> <p>运行状况检查将首先 在启动容器后 <strong>间隔</strong> 几秒钟 运行 一次，然后 在每次之前的检查完成后 <strong>间隔</strong> 几秒钟 再次<strong>运行</strong> 。</p> <p>如果单次检查花费的时间超过 <strong>超时</strong> 秒数，则认为检查失败。</p> <p>对于要考虑的容器 ，需要 <strong>重试</strong> 连续进行的运行状况检查失败 <code>unhealthy</code> 。</p> <p><strong>开始时间段</strong> 为需要时间进行引导的容器提供了初始化时间。 在此期间内的探针故障将不计入最大重试次数。 但是，如果运行状况检查在启动期间成功，则认为该容器已启动，并且所有连续失败将计入最大重试次数。</p> <p><code>HEALTHCHECK</code> Dockerfile中 只能有一条 指令。 如果您列出多个，则只有最后一个 <code>HEALTHCHECK</code> 才会生效。</p> <p><code>CMD</code> 关键字 后面的命令 可以是shell命令（例如 <code>HEALTHCHECK CMD /bin/check-running</code> ）或 <em>exec</em> 数组（与其他Dockerfile命令一样； <code>ENTRYPOINT</code> 有关详细信息 ，请参见例如 ）。</p> <p>命令的退出状态指示容器的健康状态。 可能的值为：</p> <ul><li>0：成功-容器健康且可以使用</li> <li>1：不健康-容器无法正常工作</li> <li>2：保留-请勿使用此退出代码</li></ul> <p>例如，要每五分钟检查一次，以便网络服务器能够在三秒钟内为站点的主页提供服务：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>HEALTHCHECK --interval=5m --timeout=3s \
  CMD curl -f http://localhost/ || exit 1

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>为了帮助调试失败的探针，该命令在stdout或stderr上写入的任何输出文本（UTF-8编码）都将存储在运行状况中，并可以通过查询 <code>docker inspect</code> 。 此类输出应保持简短（当前仅存储前4096个字节）。</p> <p>容器的健康状态发生更改时，将 <code>health_status</code> 生成具有新状态 的 事件。</p> <p>该 <code>HEALTHCHECK</code> 功能已在Docker 1.12中添加。</p> <h2 id="shell-🔗">SHELL <a href="#shell">🔗</a></h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该 <code>SHELL</code> 指令允许 覆盖 用于 命令 的 <em>shell</em> 形式 的默认shell 。 在Linux上 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code> ， 默认shell是 ，在Windows 上，默认shell 是 <code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code> 。 该 <code>SHELL</code> 指令 <em>必须</em> 以Docker格式的JSON形式编写。</p> <p>该 <code>SHELL</code> 指令在Windows上特别有用，在Windows上有两个常用且完全不同的本机shell： <code>cmd</code> 和 <code>powershell</code> ，以及可用的替代shell包括 <code>sh</code> 。</p> <p>该 <code>SHELL</code> 说明可以出现多次。 每个 <code>SHELL</code> 指令将覆盖所有先前的 <code>SHELL</code> 指令，并影响所有后续的指令。 例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM microsoft/windowsservercore

# Executed as cmd /S /C echo default
RUN echo default

# Executed as cmd /S /C powershell -command Write-Host default
RUN powershell -command Write-Host default

# Executed as powershell -command Write-Host hello
SHELL [&quot;powershell&quot;, &quot;-command&quot;]
RUN Write-Host hello

# Executed as cmd /S /C echo hello
SHELL [&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]
RUN echo hello

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>以下说明可以通过影响 <code>SHELL</code> 指令时， <em>壳</em> 他们的形式在一个Dockerfile使用： <code>RUN</code> ， <code>CMD</code> 和 <code>ENTRYPOINT</code> 。</p> <p>以下示例是Windows上常见的模式，可通过使用 <code>SHELL</code> 指令 进行精简 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>docker调用的命令将是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>cmd /S /C powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这效率低下有两个原因。 首先，有一个不必要的cmd.exe命令处理器（也称为Shell）被调用。 其次，<em>shell</em> 形式的 每条 <code>RUN</code> 指令都 需要 在命令前加上前缀。 <code>powershell -command</code></p> <p>为了使其更有效，可以采用两种机制之一。 一种是使用RUN命令的JSON形式，例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>RUN [&quot;powershell&quot;, &quot;-command&quot;, &quot;Execute-MyCmdlet&quot;, &quot;-param1 \&quot;c:\\foo.txt\&quot;&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>尽管JSON形式是明确的，并且不使用不必要的cmd.exe，但它确实需要通过双引号和转义来实现更多的详细信息。 另一种机制是使用 <code>SHELL</code> 指令和 <em>外壳程序</em> 形式，使Windows用户的语法更自然，尤其是与 <code>escape</code> parser指令 结合使用时 ：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># escape=`

FROM microsoft/nanoserver
SHELL [&quot;powershell&quot;,&quot;-command&quot;]
RUN New-Item -ItemType Directory C:\Example
ADD Execute-MyCmdlet.ps1 c:\example\
RUN c:\example\Execute-MyCmdlet -sample 'hello world'

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>导致：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>PS E:\docker\build\shell&gt; docker build -t shell .
Sending build context to Docker daemon 4.096 kB
Step 1/5 : FROM microsoft/nanoserver
 ---&gt; 22738ff49c6d
Step 2/5 : SHELL powershell -command
 ---&gt; Running in 6fcdb6855ae2
 ---&gt; 6331462d4300
Removing intermediate container 6fcdb6855ae2
Step 3/5 : RUN New-Item -ItemType Directory C:\Example
 ---&gt; Running in d0eef8386e97

    Directory: C:\

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----       10/28/2016  11:26 AM                Example

 ---&gt; 3f2fbf1395d9
Removing intermediate container d0eef8386e97
Step 4/5 : ADD Execute-MyCmdlet.ps1 c:\example\
 ---&gt; a955b2621c31
Removing intermediate container b825593d39fc
Step 5/5 : RUN c:\example\Execute-MyCmdlet 'hello world'
 ---&gt; Running in be6d8e63fe75
hello world
 ---&gt; 8e559e9bf424
Removing intermediate container be6d8e63fe75
Successfully built 8e559e9bf424
PS E:\docker\build\shell&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>该 <code>SHELL</code> 指令还可用于修改外壳的操作方式。 例如， <code>SHELL cmd /S /C /V:ON|OFF</code> 在Windows上 使用 ，可以修改延迟的环境变量扩展语义。</p> <p>如果 <code>SHELL</code> 需要备用shell，例如 ， 和其他 <code>zsh</code> ， 该 指令也可以在Linux上使用 。 <code>csh</code> <code>tcsh</code></p> <p>该 <code>SHELL</code> 功能已在Docker 1.12中添加。</p> <h2 id="外部实施功能-🔗">外部实施功能 <a href="#external-implementation-features">🔗</a></h2> <p>仅当使用 <a href="#buildkit">BuildKit</a> 后端 时，此功能才可用 。</p> <p>Docker构建支持实验性功能，例如缓存安装，构建机密和ssh转发，这些功能通过使用带有语法指令的构建器的外部实现启用。 要了解这些功能， <a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md" target="_blank" rel="noopener noreferrer">请参阅BuildKit信息库中的文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <h2 id="dockerfile示例-examples">Dockerfile示例 <a href="#dockerfile-examples">examples</a></h2> <p>在下面，您可以看到Dockerfile语法的一些示例。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># Nginx
#
# VERSION               0.0.1

FROM      ubuntu
LABEL Description=&quot;This image is used to start the foobar executable&quot; Vendor=&quot;ACME Products&quot; Version=&quot;1.0&quot;
RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code># Firefox over VNC
#
# VERSION               0.3

FROM ubuntu

# Install vnc, xvfb in order to create a 'fake' display and firefox
RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox
RUN mkdir ~/.vnc
# Setup a password
RUN x11vnc -storepasswd 1234 ~/.vnc/passwd
# Autostart firefox (might not be the best way, but it does the trick)
RUN bash -c 'echo &quot;firefox&quot; &gt;&gt; /.bashrc'

EXPOSE 5900
CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code># Multiple images example
#
# VERSION               0.1

FROM ubuntu
RUN echo foo &gt; bar
# Will output something like ===&gt; 907ad6c2736f

FROM ubuntu
RUN echo moo &gt; oink
# Will output something like ===&gt; 695d7793cbe4

# You'll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with
# /oink.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/solider245/VuePress-blog/edit/gh-pages/docs/文章转载/docker/Dockerfile官方参考.md" target="_blank" rel="noopener noreferrer">你要教我做事咯？</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/2/2020, 10:00:39 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/VuePress-blog/文章转载/docker/Dockerfile 基础实战：构建基础的 ubuntu14.04 镜像.html" class="prev">
        Dockerfile 基础实战：构建基础的 ubuntu14.04 镜像
      </a></span> <span class="next"><a href="/VuePress-blog/文章转载/docker/Dockerfile指令汇总及解析.html">
        Dockerfile指令汇总及解析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/VuePress-blog/assets/js/app.e4354aa1.js" defer></script><script src="/VuePress-blog/assets/js/2.398f4283.js" defer></script><script src="/VuePress-blog/assets/js/145.8f4496ac.js" defer></script>
  </body>
</html>
